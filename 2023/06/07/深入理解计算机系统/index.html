

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/hope.jpg">
  <link rel="icon" href="/img/hope.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="hope">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机基础">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统学习笔记">
<meta property="og:url" content="http://example.com/2023/06/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="hope">
<meta property="og:description" content="计算机基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220421000959782.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/08/FQpjJStIuHOxZi5.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220508232741644.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/08/ZpA6qQOlx3NR4dJ.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510162009652.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/L6zNOjwHhcDT1Mf.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/5N1RPTUScnwVQKH.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/NjDWEBIcFldSsi3.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220511181450651.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/11/a3hsfVIupGr9BKZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/11/Z4d9zcTDtWMsYVJ.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220517152506071.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/17/Ga3cYm5ZOJhPdL4.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/17/7ru92ZNpBLqao6z.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609233241439.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609234222043.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609234558373.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609235158994.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610000703892.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610001720226.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610001938109.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610163709497.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610164007260.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/10/xkvZNeIHTQAjUBd.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610171839679.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/10/WdjY1VbOuPQIUzK.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/10/cBSUmI9sZd1NLwA.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610233208043.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/MiaQ6TXko7m1ySc.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/mK6DnhsxCRkGMU2.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/uhPyHwYE9d5evgf.png">
<meta property="og:image" content="f:\CTF\787e781cc849bb40e68b8e58237ade5.jpg">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611130234576.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611163804777.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/TwRvgDjtkzSObxo.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/RDeNJFgmjy2tu6O.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611202438537.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/a5PKihr2qIzn1GM.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220613172343468.png">
<meta property="og:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220613200712252.png">
<meta property="article:published_time" content="2023-06-07T14:08:24.979Z">
<meta property="article:modified_time" content="2022-06-14T06:57:32.037Z">
<meta property="article:author" content="hope">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220421000959782.png">
  
  
  
  <title>深入理解计算机系统学习笔记 - hope</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"ZqEEnP8vrF2LzEKjCt8pL5Cf-gzGzoHsz","app_key":"6Owvec9nVB4K93xxi7CKzAqh","server_url":"https://zqeenp8v.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>hope</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解计算机系统学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-07 22:08" pubdate>
          2023年6月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          346 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入理解计算机系统学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h1><p>链接是将代码与数据组合为单一文件的过程。在现代系统中，链接由链接器的程序自动执行。</p>
<p>编译可存在如下周期：</p>
<ul>
<li>编译：源代码翻译为机器代码</li>
<li>加载：程序被加载器加载到内存并执行</li>
<li>运行：应用程序执行</li>
</ul>
<h2 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> val = sum(<span class="hljs-built_in">array</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//数组元素求和</span><br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-comment">//sum.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        s += a[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译驱动程序包括</p>
<ul>
<li>语言处理器</li>
<li>编译器</li>
<li>汇编器</li>
<li>链接器</li>
</ul>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220421000959782.png" srcset="/img/loading.gif" lazyload alt="image-20220421000959782"></p>
<p><code>Linux</code>下驱动程序的调用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Og -o prog main.c sum.c<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-O选项对程序进行优化编译、连接。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-g选项产生符号调试工具</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v选项可以查看编译具体的步骤</span><br></code></pre></td></tr></table></figure>

<p><code>C</code>预处理器(<code>cpp</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将main.c翻译成ASCII码的中间文件main.i</span><br>cpp [other arguments] man.c ./main.i<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">main.i</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;main.c&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">31 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> 1 3 4</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">32 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;main.c&quot;</span></span><br>int sum(int *a,int n);<br>int array[2] = &#123;1,2&#125;;<br><br>int main()<br>&#123;<br> int val = sum(array,2);<br> return val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>C</code>编译器(<code>cc1</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将main.i文件翻译成一个ASCII汇编语言文件main.s</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">cc1的路径 /usr/lib/gcc/x86_64-linux-gnu/9/cc1</span><br>cc1 ./main.i -Og [other arguments] -o ./main.s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">汇编代码</span><br>	.file	&quot;main.i&quot;<br>	.text<br>	.globl	main<br>	.type	main, @function<br>main:<br>.LFB0:<br>	.cfi_startproc<br>	subq	$8, %rsp<br>	.cfi_def_cfa_offset 16<br>	movl	$2, %esi<br>	leaq	array(%rip), %rdi<br>	call	sum@PLT<br>	addq	$8, %rsp<br>	.cfi_def_cfa_offset 8<br>	ret<br>	.cfi_endproc<br>.LFE0:<br>	.size	main, .-main<br>	.globl	array<br>	.data<br>	.align 8<br>	.type	array, @object<br>	.size	array, 8<br>array:<br>	.long	1<br>	.long	2<br>	.ident	&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;<br>	.section	.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure>

<p><code>C</code>汇编器(<code>as</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">汇编器将汇编代码文件翻译成可重定位目标文件</span><br>as [other arguments] -o ./main.o ./main.s<br></code></pre></td></tr></table></figure>

<p>链接器程序(<code>ld</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">链接器将可重定位的目标文件及系统目标文件组合起来，输出一个可执行目标文件</span><br>ld -o prog [system object files and args] ./main.o ./sum.o<br></code></pre></td></tr></table></figure>

<p>加载器[<code>loader</code>]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">shell调用操作系统中加载器的函数，将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的起始位置</span><br>./prog<br></code></pre></td></tr></table></figure>

<h2 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h2><p>静态链接器（<code>Linix LD</code>）</p>
<ul>
<li>输入：可重定位目标文件与命令行参数</li>
<li>输出：完全链接、可以加载和运行的可执行目标文件</li>
</ul>
<p>链接器的两个主要任务</p>
<ul>
<li>符号解析：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。符号解析的目的是将符号引用与符号定义关联起来。</li>
<li>重定位：编译器和汇编器生成从地址为0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，重定位这些节，然后修改对符号的引用，使得它们指向相应的内存位置。</li>
</ul>
<h2 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h2><p>目标文件的三种形式</p>
<ul>
<li>可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并指向。</li>
<li>共享目标文件：特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接</li>
</ul>
<p>目标模块是一个字节序列，目标文件则是存储在磁盘上地目标模块。目标文件在不同地操作系统上的文件格式各不相同</p>
<ul>
<li><code>Unix</code>系统：<code>a.out</code></li>
<li><code>Windows</code>系统：<code>PE</code></li>
<li><code>MacOS-X</code>系统：<code>Mach-O</code></li>
<li><code>Linux</code>系统：<code>ELF</code></li>
</ul>
<h2 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h2><p><code>ELF HEADER</code></p>
<ol>
<li>以16字节序列开始，记载生成该文件的系统的字的大小和字节顺序。</li>
<li><code>ELF</code>头的大小</li>
<li>目标文件的类型</li>
<li>机器类型</li>
<li>节部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ol>
<p>在<code>ELF</code>文件与节头部表之间的都是节</p>
<ul>
<li><code>.text</code>：已编译程序的机器代码</li>
<li><code>.rodata</code>：只读数据</li>
<li><code>.data</code>：已初始化的全局和静态<code>C</code>变量</li>
<li><code>.bss</code>：未初始化的全局和静态<code>C</code>变量，以及所有初始化为0的全局或静态变量</li>
<li><code>.symtab</code>：符号表，存放在程序中定义和引用的函数和全局变量的信息</li>
<li><code>.rel.text</code>：<code>.text</code>节中位置的列表，当链接器把该目标文件和其他文件组合时需要修改的位置。</li>
<li><code>.rel.data</code>：被模块引用或定义的所有全局变量的重定位信息。</li>
<li><code>.debug</code>：调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的<code>C</code>源文件。</li>
<li><code>.line</code>：原始<code>C</code>源程序中的行号和<code>.text</code>节中机器指令之间的映射。</li>
<li><code>.strtab</code>：字符串表，内容包括<code>.symtab</code>和<code>.debug</code>节中的符号表，以及节头部中的节名字。</li>
</ul>
<h2 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h2><p>可重定位目标模块<code>m</code>都有一个符号表，包含<code>m</code>定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由<strong>模块<code>m</code>定义</strong>并能被其他模块引用的<strong>全局符号</strong>。全局链接器符号对应于<strong>非静态的<code>C</code>函数</strong>和<strong>全局变量</strong>。（函数与全局变量）</li>
<li>由<strong>其他模块定义</strong>并被模块<code>m</code>引用的全局符号。这些符号称为<strong>外部符号</strong>，对应于在<strong>其他模块</strong>中定义的<strong>非静态<code>C</code>函数</strong>和<strong>全局变量</strong>。（其他文件定义的函数和全局变量）</li>
<li>只被模块<code>m</code>定义和引用的<strong>局部符号</strong>。它们对应于带<strong>static</strong>属性的<strong>C函数</strong>和<strong>全局变量</strong>。这些符号只有在<strong>模块m中可见</strong>，其他模块不可引用。</li>
</ul>
<p><strong>本地程序变量</strong>指的是局部变量，存储在堆栈中而不是段中。程序只有应用时才会分配地址空间。</p>
<p><strong>本地链接器符号</strong>指的是存储在段地址上的变量。程序编译链接时以及分配好地址空间。</p>
<p><code>C</code>语言中用<code>static</code>修饰的变量类似<code>C++</code>与<code>Java</code>中使用<code>private</code>修饰变量，是当前模块私有的。</p>
<p>符号表数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> sturct&#123;<br>	<span class="hljs-type">int</span> name; <span class="hljs-comment">//字符串表中的字节偏移</span><br>    <span class="hljs-type">char</span> type:<span class="hljs-number">4</span><span class="hljs-comment">/*类型为数据或者是函数*/</span><br>         binding:<span class="hljs-number">4</span>;<span class="hljs-comment">/*代表符号是本地的还是全局的*/</span><br>    <span class="hljs-type">char</span> reserved;<span class="hljs-comment">/*未使用*/</span><br>    <span class="hljs-type">short</span> section;<br>    <span class="hljs-type">long</span> value; <span class="hljs-comment">//符号的地址</span><br>    			<span class="hljs-comment">/*</span><br><span class="hljs-comment">    				对于重定位文件来说value是距定义目标的节的起始位置的偏移。</span><br><span class="hljs-comment">    				对于可执行目标文件来说，该值是一个绝对运行时的地址。</span><br><span class="hljs-comment">    			*/</span><br>    <span class="hljs-type">long</span> size; <span class="hljs-comment">//目标的大小</span><br>&#125;Elf64_Symbol;<br></code></pre></td></tr></table></figure>

<p>符号表需要结合字符串表寻找符号信息。</p>
<p>三个特殊的伪节，它们在节头部表中是没有条目的</p>
<ul>
<li><code>ABS</code>符号代表不该被重定位的符号</li>
<li><code>UNDEF</code>符号代表未定义的符号，本目标模块引用了，但是符号是在其他模块定义的符号</li>
<li><code>COMMON</code>符号表示还未被分配位置的未初始化的数据。<ul>
<li><code>value</code>字段给出对齐要求</li>
<li><code>size</code>给出最小的大小</li>
</ul>
</li>
<li>只有可重定位目标文件中才有这些伪节</li>
</ul>
<p><code>COMMON</code>和<code>.bss</code>的区别：<code>COMMON</code>存储未初始化的<strong>全局变量</strong>，<code>.bss</code>存储<strong>未初始化的静态变量</strong>，以及<strong>初始化为0的全局</strong>或<strong>静态变量</strong></p>
<p><img src="https://s2.loli.net/2022/05/08/FQpjJStIuHOxZi5.png" srcset="/img/loading.gif" lazyload alt="image-20220508172957864"></p>
<ul>
<li><code>Name</code>：指的是符号的字符串</li>
<li><code>Value</code>：指的是符号距离节头的偏移</li>
<li><code>Size</code>：所占内存大小</li>
<li><code>Type</code>：类型，指的是函数，变量还是文件等</li>
<li><code>Bind</code>：指的是全局变量还是局部变量</li>
<li><code>Ndx</code>：指的所在节区</li>
</ul>
<p><strong>练习题7.1</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>.symtab条目?</th>
<th>符号类型</th>
<th>在哪个模块中定义</th>
<th>节</th>
</tr>
</thead>
<tbody><tr>
<td>buf</td>
<td>是</td>
<td>外部</td>
<td>m.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp</td>
<td>是</td>
<td>全局</td>
<td>swap.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp1</td>
<td>是</td>
<td>全局</td>
<td>swap.o</td>
<td>COMMON</td>
</tr>
<tr>
<td>swap</td>
<td>是</td>
<td>全局</td>
<td>swap.o</td>
<td>.text</td>
</tr>
<tr>
<td>temp</td>
<td>否</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h2><p><strong>链接器如何解析多重定义的全局符号</strong></p>
<p><strong>函数</strong>与<strong>已初始化的全局变量</strong>是强符号</p>
<p><strong>未初始化的全局变量</strong>是弱符号</p>
<ul>
<li>规则1：不允许多个同名的强符号</li>
<li>规则2：如果有一个强符号和多个弱符号同名，那么选择强符号（有强选强）</li>
<li>规则3：如果有多个弱符号同名，那么则随机从弱符号中选择一个（多弱随机）</li>
</ul>
<p><strong>练习题7.2</strong></p>
<p>A</p>
<p>(a)REF(main.1) -&gt; DEF(main.1)</p>
<p>(b)REF(main.2)-&gt;DEF(main.1)</p>
<p>B</p>
<p>(a)两个强符号，错误</p>
<p>(b)两个强符号，错误</p>
<p>C</p>
<p>(a)REF(x.1)-&gt;DEF(x.2)</p>
<p>(b)REF(x.2)-&gt;DEF(x.2)</p>
<p>  <strong>与静态库链接</strong></p>
<p>当链接器接收的是一组可重定位目标文件</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220508232741644.png" srcset="/img/loading.gif" lazyload alt="image-20220508232741644"></p>
<p>将相关的目标模块打包成为一个单独的文件，称之为静态库作为链接器的输入。</p>
<p><img src="https://s2.loli.net/2022/05/08/ZpA6qQOlx3NR4dJ.png" srcset="/img/loading.gif" lazyload alt="image-20220508233013659"></p>
<p>当链接器输出可执行文件时，它仅仅复制静态库里被应用程序引用的目标模块。</p>
<p>当不适用静态库时，编译器开发者向用户提供库函数的几种做法：</p>
<ul>
<li><p>方法一：使用编译器识别库函数，生成指定库函数代码。</p>
<ul>
<li>缺点：C标准定义了大量的标准函数，给编译器增加了复杂性，并且库函数每次更新都需要更新一次编译器。</li>
</ul>
</li>
<li><p>方法二：将所有标准C函数都放在单独的可重定位目标模块中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc main.c /usr/lib/libc.o<br></code></pre></td></tr></table></figure>

<ul>
<li>优点：将编译器与库函数的实现分离开</li>
<li>缺点：每个可执行文件都需要包含一份标准函数副本，以及每个运行的程序都需要将这些函数副本放置在内存中。每次库函数更新都需要重新编译重定位模块</li>
</ul>
</li>
<li><p>方法三：可以将每个库函数单独编译成独立的重定位模块，但是每次连接时需要将多个重定位模块进行链接，容易出错且耗时</p>
</li>
</ul>
<p>静态库结合了方法二与方法三，将方法相近的模块编译为独立的目标模块，然后封装为一个单独的静态库文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc main.c /usr/lib/libm,a /usr/lib/libc.a<br></code></pre></td></tr></table></figure>

<p>在链接时，链接器只复制被程序引用的目标模块。</p>
<p>在<code>Linux</code>系统中，静态库以一种成为存档的特殊文件格式存放在磁盘中。存档文件命后缀<code>.a</code></p>
<p><strong>addvec.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> addcnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">addvec</span><span class="hljs-params">(<span class="hljs-type">int</span> *x,<span class="hljs-type">int</span> *y,<span class="hljs-type">int</span> *z,<span class="hljs-type">int</span> n)</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<br>	addcnt++;<br>	<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>		z[i] = x[i] + y[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>multvec.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> multcnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">multvec</span><span class="hljs-params">(<span class="hljs-type">int</span> *x,<span class="hljs-type">int</span> *y, <span class="hljs-type">int</span> *z,<span class="hljs-type">int</span> n)</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<br>	multcnt++;<br>	<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>		z[i] = x[i] * y[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c addvec.c multvec.c<br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成静态库</span><br>ar rcs libvector.a addvec.o multvec.o<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">与静态库链接</span><br>gcc -static -o prog2c main2.o ./libvector.a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">等价于</span><br>gcc -static -o prog2c main2.o -L . -lvector<br></code></pre></td></tr></table></figure>

<p><strong>链接器解析静态库引用</strong></p>
<p>链接器<strong>从左到右</strong>按照编译器驱动程序命令扫描<strong>可重定位目标文件</strong>和<strong>存档文件</strong></p>
<p>链接器维护三个集合，初始时，三个集合都为空</p>
<ul>
<li><strong>可重定位目标文件</strong>的集合E</li>
<li>一个<strong>未解析</strong>的符号集合U</li>
<li>在前面输入文件中<strong>已定义</strong>的符号集合D</li>
</ul>
<p><strong>链接器解析引用</strong></p>
<ul>
<li>对每个输入文件<code>f</code>，链接器会判断<code>f</code>是目标文件还是存档文件。如果<code>f</code>是目标文件，那么链接器将<code>f</code>添加到<code>E</code>，<code>U</code>是用来放置引用了但是没有找到定义的符号，<code>D</code>则是已经在模块中定义的符号，因此若输入文件中存在集合<code>U</code>中定义的符号，则将集合<code>U</code>中的符号放置在集合<code>D</code>中</li>
<li>如果<code>f</code>是存档文件，链接器就会将集合<code>U</code>中的符号与存档文件定义的符号进行比较。若存档文件中的成员<code>m</code>定义了集合<code>U</code>中的符号，则将成员<code>m</code>放置到集合<code>E</code>中，将集合<code>U</code>中的符号移动到集合<code>D</code>中，对存档文件的每个成员都依次进行该过程，直到<code>U</code>和<code>D</code>都不发生变化。那么不包含在集合<code>E</code>中的成员目标文件都会被抛弃，链接器则继续输入下一个文件。</li>
<li>若链接器完成了所有输入文件的解析，但是发现集合<code>U</code>非空，那么就会发出异常并终止。否则就合并和重定位<code>E</code>中的目标文件，构建输出的可执行文件。</li>
</ul>
<p><strong>练习题7.3</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">A.p.o -&gt; libx.a</span><br>gcc p.o libx.a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">B.p.o -&gt; libx.a -&gt; liby.a</span><br>gcc p.o libx.a liby.a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">C.p.o -&gt; libx.a -&gt; liby.a且liby.a-&gt;libx.a-&gt;p.o</span><br>gcc p.o libx.a liby.a libx.a <br></code></pre></td></tr></table></figure>

<h2 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h2><p>重定位由两个步骤组成</p>
<ul>
<li>重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。接着链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节以及赋给输入模块定义的每个符号。此时，程序中的每条指令和全局变量都有唯一的运行时内存地址。（往符号写入地址）</li>
<li>重定位节中的符号引用：链接器修改代码节和数据节中对符号的引用，使得它们指向正确的运行时地址。（将符号的地址重定位），重定位依赖于可重定位目标模块中称为<strong>重定位条目的数据结构</strong></li>
</ul>
<p><strong>重定位条目</strong></p>
<p>当编译器遇到最终未知的目标引用时，它会生成一个重定位条目，用于告知链接器在目标文件合并为可执行文件时如何修改这个引用。</p>
<p>代码的重定位条目放在<code>.rel.text</code>中</p>
<p>初始化数据的重定位条目放在<code>.rel.data</code>中</p>
<p><code>ELF</code>重定位条目的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">long</span> offset; <span class="hljs-comment">//标识需要被修改的引用的节偏移</span><br>    <span class="hljs-type">long</span> type:<span class="hljs-number">32</span>, <span class="hljs-comment">//用于告知链接器如何修改新的引用</span><br>    	symbol:<span class="hljs-number">32</span>; <span class="hljs-comment">//标识被修改引用应该指向的符号</span><br>    <span class="hljs-type">long</span> addend; <span class="hljs-comment">//有些重定位类型需要它作为偏移调整</span><br>&#125;Elf64_Rela;<br></code></pre></td></tr></table></figure>

<p>两种最基本的重定位类型</p>
<ul>
<li><code>R_X86_64_PC32</code>：重定位一个使用32位<code>PC</code>相对地址的引用</li>
<li><code>R_X86_64_32</code>：重定位一个使用32位绝对地址的引用</li>
</ul>
<p><strong>重定位符号引用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">foreach section s&#123; <span class="hljs-comment">//遍历每个节</span><br>    foreach relocation entry r&#123; <span class="hljs-comment">//遍历每个重定位结构条目</span><br>        refptr = s + r.offset; <span class="hljs-comment">//节地址+节偏移地址 = 重定位条目的地址</span><br>        <span class="hljs-keyword">if</span>(r.type == R_X86_64_PC32)&#123; <span class="hljs-comment">//使用PC相对地址引用</span><br>            refaddr = ADDR(s) + r.offset;<br>            *refptr = (<span class="hljs-type">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r.type == R_X86_64_32) <span class="hljs-comment">//使用绝对地址</span><br>            *refptr = (<span class="hljs-type">unsigned</span>)(ADDR(r.symbol) + r.addend);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>main.o</code>反汇编代码</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220510162009652.png" srcset="/img/loading.gif" lazyload alt="image-20220510162009652"></p>
<p><code>main</code>函数中有两个重定位引用，并且汇编器为每个引用产生一个重定位条目，显示在该引用的后面。<code>array</code>使用<code>PC</code>相对地址进行重定位，而<code>sum</code>使用绝对地址引用</p>
<p><strong>重定位PC相对引用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">e: e8 00 00 00 00 callq 13 &lt;main+0x13&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>e8</code>：是<code>call</code>指令的操作码</li>
</ul>
<p>相应的重定位条目<code>r</code>由4个字段组成</p>
<ul>
<li><code>r.offset</code> &#x3D; <code>0xf</code> <ul>
<li><code>call</code>指令偏移<code>0xe</code>，但是<code>e8</code>后一个字节码偏移为<code>0xf</code></li>
</ul>
</li>
<li><code>r.symbol</code> &#x3D; <code>sum</code><ul>
<li>该重定位项为<code>sum</code></li>
</ul>
</li>
<li><code>r.type</code> &#x3D; <code>R_X86_64_PC32</code><ul>
<li>采用PC相对引用</li>
</ul>
</li>
<li><code>r.addend</code> &#x3D; <code>-4</code><ul>
<li>当前需要填充字节码的地址与下一条指令的距离</li>
</ul>
</li>
</ul>
<p>重定位的流程</p>
<ul>
<li><p>首先链接器确定了 节地址<code>ADDR(s)</code> &#x3D; <code>ADDR(.text)</code> &#x3D; <code>0x4004d0</code>与确定了符号地址<code>ADDR(r.symbol)</code> &#x3D; <code>ADDR(sum)</code> &#x3D; <code>0x4004e8</code></p>
</li>
<li><p>接着计算引用的运行地址$refaddr &#x3D; ADDR(s) + r.offset\&#x3D;0x4004d0+0xf\0x4004df$</p>
</li>
<li><p>然后修改该引用，使其指向函数实际运行地址$*refptr &#x3D; (unsigned)(ADDR(r.symbol)+r.addend - refaddr)\&#x3D;(unsigned)(0x4004e8 + (-4) - 0x4004df)\&#x3D;(unsigned)(0x5)$</p>
</li>
<li><p>最后，指令被修改为</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">4004e8:e8 05 00 00 00 callq 4004e8&lt;sum&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>在指令执行时，CPU执行的步骤为<ul>
<li>将<code>PC</code>(下一条指令)压入栈中</li>
<li>计算地址$PC &lt;-  PC + 0x5 &#x3D; 0x4004e3(下一条指令的地址) + 0x5 &#x3D; 0x4004e8$</li>
</ul>
</li>
</ul>
<p><strong>重定位绝对引用</strong></p>
<p><code>array</code>的重定位条目为</p>
<ul>
<li><code>r.offset</code> &#x3D; <code>0xa</code></li>
<li><code>r.symbol</code> &#x3D; <code>array</code></li>
<li><code>r.type</code> &#x3D; <code>R_X86_64_32</code></li>
<li><code>r.addend</code> &#x3D; <code>0</code></li>
</ul>
<p>重定位流程</p>
<ul>
<li>首先确定符号运行地址：<code>ADDR(r.symbol) = ARRD(array) = 0x601018</code></li>
<li>接着链接器修改引用$*refptr &#x3D; (unsigned)(ADDR(r.symbol) + r.addend)\&#x3D; (unsigend)(0x601018+0)\(unsigned)(0x601018)$</li>
<li>最后可执行目标文件下的指令为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">4004d9: bf 18 10 60 00 mob $0x601018,%edi<br></code></pre></td></tr></table></figure>

<h2 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h2><p>二进制文件包含加载程序到内存并运行它所需的所有信息</p>
<p><img src="https://s2.loli.net/2022/05/10/L6zNOjwHhcDT1Mf.png" srcset="/img/loading.gif" lazyload alt="image-20220510175440833"></p>
<p><strong>ELF文件格式</strong></p>
<ul>
<li><code>ELF</code>头描述文件的总体格式，包含程序的入口点</li>
<li><code>.init</code>节定义了个函数，叫做<code>_init</code>，程序的初始化代码会调用它。由于可执行文件是完全链接的（已被重定位），所以它不再需要<code>.rel</code>节</li>
</ul>
<p>程序头部表描述了可执行文件到连续的内存段的映射</p>
<p><img src="https://s2.loli.net/2022/05/10/5N1RPTUScnwVQKH.png" srcset="/img/loading.gif" lazyload alt="image-20220510180231214"></p>
<ul>
<li><code>off</code>：目标文件中的偏移</li>
<li><code>vaddr/paddr</code>：内存地址</li>
<li><code>align</code>：对齐要求</li>
<li><code>filesz</code>：目标文件中的段大小</li>
<li><code>memsz</code>：内存中的段大小</li>
<li><code>flags</code>：运行时访问权限</li>
</ul>
<h2 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h2><p>执行目标文件所执行的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./prog<br></code></pre></td></tr></table></figure>

<p>可执行文件是通过加载器运行。<code>execve</code>函数可以用来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。将程序复制到内存并运行的过程叫做加载。</p>
<p><img src="https://s2.loli.net/2022/05/10/NjDWEBIcFldSsi3.png" srcset="/img/loading.gif" lazyload alt="image-20220510181119921"></p>
<p>在<code>Linux x86-64</code>系统中</p>
<ul>
<li>代码段总是从地址<code>0x400000</code>处开始，后面紧接着是数据段</li>
<li>堆空间在数据段之后，通过<code>malloc</code>库向上增长，堆后面的区域是为共享模块保留的</li>
<li>用户栈总是从最大的合法用于地址（$2^{48}-1$）开始，向较小的内存地址增长</li>
<li>从地址（$2^{48}$）开始，为内核中的代码和数据保留的，内核是操作系统驻留在内存的部分</li>
</ul>
<p>加载器加载可执行文件的流程</p>
<ul>
<li>当加载器运行时，创建上图所示的内存映像</li>
<li>在程序头部表的引导下加载器将可执行文件的片复制到代码段和数据段</li>
<li>加载器跳转到程序的入口点，也就是<code>_start</code>函数的地址</li>
<li><code>_start</code>函数启动<code>__libc_start_main</code>函数，该函数初始化执行环境，接着调用用户层的<code>main</code>函数，处理<code>main</code>函数的返回值，并且在需要的时候把控制返回给内核</li>
</ul>
<p><strong>加载器的实际工作流程</strong></p>
<p><code>Linux</code>系统中的每个程序运行在一个进程上下文（抽象认为进程自己的数据记录），并且每个进程拥有自己的虚拟空间。</p>
<ul>
<li>当<code>shell</code>运行一个可执行文件时，父<code>shell</code>进程会生成一个子进程，它是父进程的一个复制。子进程通过<code>execve</code>系统调用启动加载器。</li>
<li>加载器删除现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的堆栈空间会被初始化为零。</li>
<li>通过将虚拟内存地址空间中的页映射到可执行文件的页大小的片，新的代码和数据会被初始化为可执行文件的内容。</li>
<li>加载器跳转到<code>_start</code>函数地址，最终调用用户<code>main</code>函数。</li>
</ul>
<h2 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h2><p>静态库的缺陷</p>
<ul>
<li>需要定期维护和更新，若需要用到最新版本的库，需要显示的将程序与库重新链接</li>
<li>几乎所有的C程序都需要使用标准<code>I/O</code>函数，因此使用静态库的时候，程序运行时，就需要将库函数的副本拷贝到内存中，因此在系统上存在着成千上万的<code>I/O</code>库函数的副本，浪费内存空间</li>
</ul>
<p>共享库是一个目标模块，在可执行文件运行或加载时，可以加载到任意的内存空间，并且和内存中的程序链接起来，该过程称之为动态链接，是由一个动态链接器的程序执行的。</p>
<p>共享库以两种方式被可执行文件所共享</p>
<ul>
<li>所有可执行的目标文件共享<code>.so</code>文件中的代码与数据</li>
<li>在内存中，一个共享库的<code>.text</code>节的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编译共享库</span><br>gcc -shared -fpic -o libvector.so addvec.c multvec.c<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-fpic选项指示编译器生成与位置无关的代码</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-shared选项指示链接器创建一个共享的目标文件</span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220511181450651.png" srcset="/img/loading.gif" lazyload alt="image-20220511181450651"></p>
<p>动态链接创建可执行文件步骤</p>
<ul>
<li>首先静态执行一些链接</li>
<li>然后再程序加载时，动态完成链接</li>
</ul>
<p>没有代码和数据复制到<strong>可执行文件</strong>中，<strong>链接器</strong>复制了重定位和符号表信息（与静态链接不同点，静态链接复制了代码和数据）</p>
<p>加载器加载和运行可执行文件（部分链接）</p>
<ul>
<li>部分链接的可执行文件包含<code>.interp</code>节（包含动态链接的路径），加载器加载和运行动态链接器，动态链接器完成任务如下<ul>
<li>重定位<code>libc.so</code>的文本和数据</li>
<li>重定位<code>libvector.so</code>的文件和输</li>
<li>重定位可执行文件对由<code>libc.so</code>和<code>libvector.so</code>定义的符号的引用</li>
<li>最后，动态链接器将控制传递给应用程序，此时共享库的位置就固定，在程序执行时都不会改变了</li>
</ul>
</li>
</ul>
<h2 id="7-11-从应用程序中加载和链接共享库"><a href="#7-11-从应用程序中加载和链接共享库" class="headerlink" title="7.11 从应用程序中加载和链接共享库"></a>7.11 从应用程序中加载和链接共享库</h2><p><code>Linux</code>系统为动态链接器提供了一个简单的接口，允许引用程序在运行时加载和链接共享库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flag)</span>; <span class="hljs-comment">//打开与加载共享库</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle,<span class="hljs-type">char</span> *symbol)</span>; <span class="hljs-comment">//获取函数地址</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dlclose</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle)</span>; <span class="hljs-comment">//卸载共享库</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">dlerror</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//描述调用dlopen、dlsym或者dlclose函数发送的最近的错误</span><br></code></pre></td></tr></table></figure>

<p><strong>dll.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//gcc -rdynamic -o prog2r dll.c -ldl</span><br><span class="hljs-comment">//-ldl参数为显示加载共享库</span><br><span class="hljs-comment">//-rdynamic参数为通知链接器将所有符号添加到动态符号表</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">void</span> *handle;<br>	<span class="hljs-type">void</span> (*addvec)(<span class="hljs-type">int</span> *,<span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *,<span class="hljs-type">int</span>);<br>	<span class="hljs-type">char</span> *error;<br>	<br>	handle = dlopen(<span class="hljs-string">&quot;./libvector.so&quot;</span>,RTLD_LAZY); <span class="hljs-comment">//打开共享库，延迟绑定的方式</span><br>	<span class="hljs-keyword">if</span>(!handle)&#123;<br>		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s\n&quot;</span>,dlerror());<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<br>	addvec = dlsym(handle,<span class="hljs-string">&quot;addvec&quot;</span>);<span class="hljs-comment">//获取addvec函数的地址</span><br>	<span class="hljs-keyword">if</span>((error = dlerror())!=<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s\n&quot;</span>,error);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<br>	addvec(x,y,z,<span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>,z[<span class="hljs-number">0</span>],z[<span class="hljs-number">1</span>]);<br>	<br>	<span class="hljs-keyword">if</span>(dlclose(handle)&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//关闭共享库</span><br>		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s\n&quot;</span>,dlerror());<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-12-位置无关代码"><a href="#7-12-位置无关代码" class="headerlink" title="7.12 位置无关代码"></a>7.12 位置无关代码</h2><p>多个进程是如何共享程序中的一个副本</p>
<ul>
<li>方案一：为每个共享库分配一个事先预备的专用的地址空间片<ul>
<li>问题一：空间利用率不高<ul>
<li>即使程序不适用该库也需要预留空间</li>
<li>当共享库修改时需要判断预留空间是否足够，不足够需要找新的空间</li>
<li>当创建新的共享库，需要再次找新的内存空间</li>
<li>共享库数量多，会将内存空间分割为大小不均匀的片段</li>
<li>对于不同的操作系统，给库分配的空间大小不一</li>
</ul>
</li>
</ul>
</li>
<li>方案二：提供一种编译方式，使得共享库可以加载到内存的任何位置，并且无需链接器修改，这种编译方式被称之为位置无关代码(Position-Independent Code,PIC)，使用<code>-fpic</code>参数指示编译系统生成<code>PIC</code>代码</li>
</ul>
<p><strong>PIC数据引用</strong></p>
<ul>
<li>数据段与代码段中数据与指令的偏移是常量</li>
<li>在数据段开始的地方创建了全局偏移量表(Global Offset Table,GOT)，GOT表中每个被引用的全局变量都会有一个8字节条目（GOT项地址），并且编译器为每个条目生成一个重定位记录，加载时，动态链接器会重定位GOT中的每个条目，使该条目包含正确的变量地址。每个目标模块都有属于自己的GOT</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/11/a3hsfVIupGr9BKZ.png" srcset="/img/loading.gif" lazyload alt="image-20220511232959402"></p>
<p><strong>PIC函数调用</strong></p>
<p>延迟绑定：将过程地址的绑定延迟到第一次调用该过程时，延迟绑定采用两个数据结构进行交互实现，GOT和过程链接表(Procedure Linkage Table, PLT)</p>
<ul>
<li>过程链接表(PLT)。PLT是一个数组，每个条目为16字节代码。<ul>
<li>PLT[0]用于跳转到动态链接器中。</li>
<li>PLT[1]调用系统启动函数(__libc_start_main)，用于初始化执行环境，调用<code>main</code>函数并处理其中返回值。</li>
<li>PLT[2]开始的条目调用用户代码调用的函数</li>
</ul>
</li>
<li>全局偏移表(GOT)。GOT是一个数组，每个条目是8字节地址。<ul>
<li>GOT[0]与GOT[1]是动态链接器解析函数地址时使用的参数信息</li>
<li>GOT[2]时动态链接器在<code>ld-linux.so</code>模块中的入口点。其余的每个条目对应一个被调用的函数，其地址需要在运行时被解析。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/11/Z4d9zcTDtWMsYVJ.png" srcset="/img/loading.gif" lazyload alt="image-20220511235250490"></p>
<p>延迟解析地址步骤</p>
<ul>
<li>首先跳转到<code>addvec</code>的<code>plt</code>地址，即程序调用进入<code>PLT[2]</code>，这是<code>addvec</code>的<code>PLT</code>条目</li>
<li>第一条<code>PLT</code>指令通过<code>GOT[4]</code>进行间接跳转，在延迟绑定完成之前，都是跳转到<code>PLT</code>条目的下调指令</li>
<li>把<code>addvec</code>的<code>ID</code>压入栈中，<code>PLT[2]</code>跳转到<code>PLT[0]</code>，即动态链接器的函数地址</li>
<li><code>PLT[0]</code>将<code>GOT[1]</code>项内容压入栈中，通过<code>GOT[2]</code>跳转到动态链接器中。动态链接器通过压入的两个参数确定<code>addvec</code>函数的实际地址，最后将实际地址重写<code>GOT</code>项内容，再把控制传递给<code>addvec</code>函数</li>
</ul>
<h2 id="7-13-库打桩机制"><a href="#7-13-库打桩机制" class="headerlink" title="7.13 库打桩机制"></a>7.13 库打桩机制</h2><p><code>Linux</code>链接器使用库打桩技术，允许截获对共享库函数的调用，取而代之执行自己的代码（类似<code>Windows</code>的<code>Hook</code>技术）。</p>
<p>库打桩的基本思想：创建一个包装函数，它的原型与目标函数一致，使用打桩技术，使得系统调用包装函数而不是原函数，包装函数内会先执行自己的逻辑后再调用原函数并把返回值返回给调用者</p>
<p>打桩可以发生在编译、链接或程序加载和执行时</p>
<h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>本地定义一个<code>malloc.h</code>头文件，将<code>malloc</code>函数定义为自定义的<code>mymalloc</code>函数，编译时使用<code>-I</code>参数强制载入本地库文件，完成编译时库打桩技术</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*编译*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">gcc -DCOMPILETIME -c mymalloc.c</span><br><span class="hljs-comment">gcc -I . -o intc int.c mymalloc.o</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">编译参数解析：</span><br><span class="hljs-comment">1.-D为定义宏</span><br><span class="hljs-comment">2.-I表示搜素库的目录</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">//int.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>);<br>	<span class="hljs-built_in">free</span>(p);<br>	<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//malloc.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> malloc(size) mymalloc(size)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free(ptr) myfree(ptr)</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mymalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">myfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br><br><span class="hljs-comment">//mymalloc.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> COMPILETIME</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mymalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>	<span class="hljs-type">void</span> *ptr = <span class="hljs-built_in">malloc</span>(size);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%d) = %p\n&quot;</span>,(<span class="hljs-type">int</span>)size,ptr);<br>	<span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>	<span class="hljs-built_in">free</span>(ptr);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>,ptr);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">out:</span><br><span class="hljs-comment">malloc(32) = 0x558f09de52a0</span><br><span class="hljs-comment">free(0x558f09de52a0)</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>

<h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>编译时使用参数<code>--wrap f</code>可以修改引用时的符号，符号<code>f</code>会被修改为<code>__wrap_f</code>而<code>__real_f</code>会被修改为符号<code>f</code>从而完成打桩技术</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//mymalloc.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LINKTIME</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> *__real_malloc(<span class="hljs-type">size_t</span> size);<br><span class="hljs-type">void</span> __real_free(<span class="hljs-type">void</span> *ptr);<br><br><span class="hljs-type">void</span> *__wrap_malloc(<span class="hljs-type">size_t</span> size)<br>&#123;<br>	<span class="hljs-type">void</span> *ptr = __real_malloc(size); <span class="hljs-comment">//__real_malloc会被替换为malloc</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%d) = %p \n&quot;</span>,(<span class="hljs-type">int</span>)size,ptr);<br>	<span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> __wrap_free(<span class="hljs-type">void</span> *ptr)<br>&#123;<br>	__real_free(ptr);<span class="hljs-comment">//__real_free会被替换为free</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>,ptr);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//int.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>); <span class="hljs-comment">//malloc会被替换为__wrap_malloc</span><br>	<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//free会被替换为__wrap_free</span><br>	<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>自定义<code>.so</code>文件，使用<code>LD_PRELOAD</code>环境变量，使得系统载入我们自定义的<code>.so</code>文件完成打桩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//课本例子</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">gcc -DRUMTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//mymalloc.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RUNTIME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br> <br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">void</span> *(*mallocp)(<span class="hljs-type">size_t</span> size);<br>    <span class="hljs-type">char</span> *error;<br> <br>    mallocp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>); <span class="hljs-comment">//RTLD_NEXT为库中第一个出现的函数</span><br>    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(error, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> *ptr = mallocp(size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="hljs-type">int</span>)size, ptr);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*freep)(<span class="hljs-type">void</span> *) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *error;<br> <br>    <span class="hljs-keyword">if</span> (!ptr)<br>        <span class="hljs-keyword">return</span>;<br> <br>    freep = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(error, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    freep(ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//int.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>);<br>	<span class="hljs-built_in">free</span>(p);<br>	<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是课本例子无法运行</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220517152506071.png" srcset="/img/loading.gif" lazyload alt="image-20220517152506071"></p>
<p>参考网上解析<a target="_blank" rel="noopener" href="https://blog.csdn.net/damon_x/article/details/111551317">CSAPP第三版运行时打桩Segmentation fault</a></p>
<p>进入gdb调试，使用<code>(gdb) set env LD_PRELOAD=./mymalloc.so</code>设置环境变量，运行程序，输入<code>bt</code>查看栈回溯</p>
<p><img src="https://s2.loli.net/2022/05/17/Ga3cYm5ZOJhPdL4.png" srcset="/img/loading.gif" lazyload alt="image-20220517152718348"></p>
<p>发现<code>print</code>和<code>malloc</code>函数一直互相递归调用，这是因为<code>printf</code>函数里使用<code>malloc</code>函数，而自定义的<code>.so</code>文件又调用了<code>printf</code>函数因此产生了死循环。</p>
<p>网上教程修改后的文件为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RUNTIME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br> <br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">void</span> *(*mallocp)(<span class="hljs-type">size_t</span> size);<br>    <span class="hljs-type">char</span> *error;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> print_times = <span class="hljs-number">0</span>;<br>    print_times++;<br>    mallocp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(error, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> *ptr = mallocp(size);<br>    <span class="hljs-keyword">if</span>(print_times == <span class="hljs-number">1</span>)<span class="hljs-comment">//防止了递归调用</span><br>    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="hljs-type">int</span>)size, ptr);<br>    print_times = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*freep)(<span class="hljs-type">void</span> *) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *error;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> print_times = <span class="hljs-number">0</span>;<br>    print_times++; <br>    <span class="hljs-keyword">if</span> (!ptr)<br>        <span class="hljs-keyword">return</span>;<br> <br>    freep = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(error, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    freep(ptr);<br>    <span class="hljs-keyword">if</span>(print_times == <span class="hljs-number">1</span>)<br>    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    print_times = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,World!\n&quot;</span>);<br>	<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/05/17/7ru92ZNpBLqao6z.png" srcset="/img/loading.gif" lazyload alt="image-20220517153341247"></p>
<h2 id="7-14-处理目标文件的工具"><a href="#7-14-处理目标文件的工具" class="headerlink" title="7.14 处理目标文件的工具"></a>7.14 处理目标文件的工具</h2><ul>
<li>AR：创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS：列出一个目标文件中所有可打印的字符串</li>
<li>NM：列出一个目标文件的符号表定义的符号</li>
<li>SIZE：列出目标文件中节的名字和大小</li>
<li>READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li>
<li>OBJDUMP：显示一个目标文件中所有的信息。可以反汇编<code>.text</code>节中的二进制指令</li>
<li>LDD：列出一个可执行文件再运行时所需的共享库</li>
</ul>
<h1 id="第8章-异常处理控制流"><a href="#第8章-异常处理控制流" class="headerlink" title="第8章 异常处理控制流"></a>第8章 异常处理控制流</h1><p>从给处理器上电开始，直到处理器断电，程序计算器中的序列为$a_0,a_1,…,a_{n-1}$，其中每个$a_k$是某个相应的指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过度成为控制转移。这样的控制转移序列称之为处理器控制流。</p>
<p>平滑序列：$I_k$和$I_{k+1}$在内存中相邻</p>
<p>平滑流突变：$I_k$和$I_{k+1}$不相邻，通常是由于跳转、调用和返回指令造成，这种突变是内部程序状态中的变化</p>
<p>系统状态变化例如：硬件定时器定期产生信号、包到达网络适配器后、程序向磁盘请求数据以及子进程终止需要通知父进程等</p>
<p>现代系统通过使控制流发生突变来应对这些情况，上述突变被称之为异常控制流（Exceptional Control Flow,ECF）</p>
<h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>异常就是控制流中的突变，用来相应处理器状态中的某些变化</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609233241439.png" srcset="/img/loading.gif" lazyload alt="image-20220609233241439"></p>
<ul>
<li>状态被编码为不同的位和信号</li>
<li>状态变化被称之为事件</li>
<li>事件可能与当前指令的直接相关<ul>
<li>虚拟内存缺页</li>
<li>算术溢出</li>
<li>试图除0</li>
</ul>
</li>
<li>时间也可能与当前指令无关<ul>
<li>系统定时器产生信号</li>
<li>I&#x2F;O请求完成</li>
</ul>
</li>
</ul>
<p>处理器检测到事件发生，就会去异常表的跳转表进行查询并进行间接过程调用，跳转到专门处理此类事件的异常处理程序中进行处理。处理程序完成后，根据异常事件的类型可能会发生以下三种情况之一</p>
<ul>
<li>处理程序将控制返回给当前指令$I_{curr}$</li>
<li>处理程序将控制返回给$I_{next}$，如果没有异常则会执行下一条指令</li>
<li>处理程序终止被中断的程序</li>
</ul>
<h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>处理器设计者分配的异常号</p>
<ul>
<li>被零除</li>
<li>缺页</li>
<li>内存访问违例</li>
<li>断点</li>
<li>算术运算溢出</li>
</ul>
<p>操作系统内核（操作系统驻留在内存的部分）</p>
<ul>
<li>外部I&#x2F;O设备的信号</li>
</ul>
<p>系统启动时，操作系统分配和初始化一张称之为异常表的跳转表，表目k包含异常k的处理程序地址</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609234222043.png" srcset="/img/loading.gif" lazyload alt="image-20220609234222043"></p>
<p>异常表的起始地址放在异常表基址寄存器中</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609234558373.png" srcset="/img/loading.gif" lazyload alt="image-20220609234558373"></p>
<p>异常的调用过程与过程调用的不同之处</p>
<ul>
<li>过程调用时会将返回地址压入栈中，但是根据异常的类型，返回地址可能是当前指令也可能是下一条指令</li>
<li>处理器会将额外的处理器状态压入栈中，程序返回时，需要用到这些状态。</li>
<li>若控制从用户程序转移到内核，所有这些项目都将会被压入内核栈中，而不是压入到用户栈中</li>
<li>异常处理程序运行在内核模式下，因此具有对系统资源的访问权限</li>
</ul>
<h3 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h3><p>异常分为四类：中断、故障、陷阱、终止。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220609235158994.png" srcset="/img/loading.gif" lazyload alt="image-20220609235158994"></p>
<ul>
<li>中断</li>
</ul>
<p>中断是异步发生的，来自处理器外部的I&#x2F;O设备的信号的结果。例如网络适配器、磁盘控制器和定时器芯片，这些设备通过向处理器新品上的引脚发信号，并将异常号放到系统总线上，来触发中断，异常号用于标识引起中断的设备。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610000703892.png" srcset="/img/loading.gif" lazyload alt="image-20220610000703892"></p>
<ul>
<li>陷阱和系统调用</li>
</ul>
<p>陷阱是有意而为的异常，陷阱最重要用途是在用户态与内核态之间提供一个接口，被称之为系统调用。</p>
<p>用户程序需要向内核请求服务，比如读文件（read）、创建新进程（fork）、加载新程序（execve）或终止当前进程（exit）。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610001720226.png" srcset="/img/loading.gif" lazyload alt="image-20220610001720226"></p>
<ul>
<li>故障</li>
</ul>
<p>故障由错误情况引起，它可能能够被修正。当故障发生时，处理器就会将控制转移给故障处理程序。当故障能被修正（例如缺页），则将控制返回给引起故障的指令，重新执行它。否则，处理程序返回到内核中<code>abort</code>例程，<code>abort</code>例程会终止引起故障的应用程序。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610001938109.png" srcset="/img/loading.gif" lazyload alt="image-20220610001938109"></p>
<ul>
<li>终止</li>
</ul>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如<code>DRAM</code>或<code>SRAM</code>位被损坏时发生的奇偶错误。终止处理程序不会将控制返回给应用程序，而是交给<code>abort</code>例程</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610163709497.png" srcset="/img/loading.gif" lazyload alt="image-20220610163709497"></p>
<h3 id="8-1-3-Linux-x2F-x86-64系统中的异常"><a href="#8-1-3-Linux-x2F-x86-64系统中的异常" class="headerlink" title="8.1.3 Linux&#x2F;x86-64系统中的异常"></a>8.1.3 Linux&#x2F;x86-64系统中的异常</h3><p><code>x86-64</code>系统定义了256种不同的异常类型</p>
<ul>
<li>0-31的号码由<code>Intel</code>架构师定义</li>
<li>32-255的号码由操作系统定义</li>
</ul>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610164007260.png" srcset="/img/loading.gif" lazyload alt="image-20220610164007260"></p>
<p><strong>1.Linux&#x2F;x86-64故障和终止</strong></p>
<ul>
<li>除法错误：应用试图除以零，或者当处罚指令的结果对于目标操作数来说太大了，<code>Unix</code>不会对除法错误进行恢复处理，而是直接终止程序。<code>Linux Shell</code>报告位浮点异常</li>
<li>一般保护故障：引用未定义的虚拟内存区域，写只读区域，<code>Linux Shell</code>报告为段故障</li>
<li>缺页：缺页异常时会重新执行故障的指令</li>
<li>机器检查：监测到致命的硬件错误</li>
</ul>
<p><strong>2.Linux&#x2F;x86-64 系统调用</strong></p>
<p>当应用程序想要请求内核服务时使用，例如读写文件或创建进程</p>
<p><img src="https://s2.loli.net/2022/06/10/xkvZNeIHTQAjUBd.png" srcset="/img/loading.gif" lazyload alt="image-20220610165218222"></p>
<p>c语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;hello,world\n&quot;</span>,<span class="hljs-number">13</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section .data<br>string:<br>	.ascii &quot;hello,world\n&quot;<br>string_end:<br>	.equ len,string_end -string<br>.section .text<br>.global main<br>main:<br>	movq $1,%rax ;系统调用号<br>	movq $1,%rdi ;键盘输入<br>	movq $string,%rsi ;存储地址<br>	movq $len,%rdx ;长度<br>	syscall ;调用write(1,&quot;hello,world\n&quot;,13)<br>	<br>	movq $60,%rax ;调用exit(0)<br>	movq $0,%rdi<br>	syscall<br></code></pre></td></tr></table></figure>

<h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>进程：正在执行的程序</p>
<p>系统种的每个程序都运行在某个进程的上下文种。</p>
<p>上下文由程序正确运行所需的状态组成的</p>
<ul>
<li>程序中的代码与数据</li>
<li>栈、通用寄存器的内容</li>
<li>程序计数器（PC）</li>
<li>环境变量</li>
<li>打开文件描述符</li>
</ul>
<p>执行目标文件的流程</p>
<ul>
<li>在<code>shell</code>中输入可执行目标文件的名字</li>
<li><code>shell</code>创建新的进程，在该进程的上下文中运行该可执行目标文件</li>
</ul>
<h3 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h3><p><code>PC</code>值得序列称之为逻辑控制流</p>
<h3 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称之为并发流</p>
<p>两个逻辑流并发的运行在不同的处理器核或者计算机上，这为并行流。</p>
<p><strong>练习题8.1</strong></p>
<p>考虑三个具有下述起始和结束事件的进程</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610171839679.png" srcset="/img/loading.gif" lazyload alt="image-20220610171839679"></p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">  <span class="hljs-comment">0     1     2   3   4    5</span><br>  <br><span class="hljs-comment">A</span> <span class="hljs-literal">--</span>          <span class="hljs-literal">--</span><br><br><span class="hljs-comment">B</span>       <span class="hljs-literal">--</span>            <span class="hljs-literal">--</span><br><br><span class="hljs-comment">C</span>                 <span class="hljs-literal">--</span>       <span class="hljs-literal">--</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>进程对</th>
<th>并发的？</th>
</tr>
</thead>
<tbody><tr>
<td>AB</td>
<td>并发的</td>
</tr>
<tr>
<td>AC</td>
<td>不是并发的</td>
</tr>
<tr>
<td>BC</td>
<td>并发的</td>
</tr>
</tbody></table>
<h3 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h3><p>进程为每个程序提供它的私有地址空间</p>
<p><code>Linux</code>进程的地址空间的组织结构</p>
<p><img src="https://s2.loli.net/2022/06/10/WdjY1VbOuPQIUzK.png" srcset="/img/loading.gif" lazyload alt="image-20220610172531499"></p>
<h3 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h3><p>今存起通常使用某个控制寄存器中的一个<strong>模式位</strong>区分用户态与内核态，该寄存器描述了进程当前享有的特权。</p>
<p>当设置了模式位时，进程运行在内核模式中</p>
<p>没有设置模式位时，进程运行子用户模式中</p>
<p>进程通过中断、故障或者陷入系统调用这样的异常从用户态转化为内核态。</p>
<p><code>/proc</code>文件系统，允许用户模式进程访问内核数据结构的内容</p>
<ul>
<li><code>/proc/cpuinfo</code>：CPU类型</li>
<li><code>/proc/&lt;process-id&gt;/maps</code>：某个特殊的进程使用的内存段</li>
<li><code>/sys</code>：输出系统总线和设备的额外的底层信息</li>
</ul>
<h3 id="8-25-上下文切换"><a href="#8-25-上下文切换" class="headerlink" title="8.25 上下文切换"></a>8.25 上下文切换</h3><p>操作系统内核使用上下文切换的异常控制流实现多任务</p>
<p>内核选择启用哪个进程的决策称之为调度，由调度器处理</p>
<p>内核调度过程</p>
<ul>
<li>内核选择新进程抢占当前进程</li>
<li>上下文切换<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/10/cBSUmI9sZd1NLwA.png" srcset="/img/loading.gif" lazyload alt="image-20220610174537704"></p>
<h2 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s: %s\n&quot;</span>,msg,strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h2><h3 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">/* pid_t = int */</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//返回进程的PID</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//返回父进程的PID</span><br></code></pre></td></tr></table></figure>

<h3 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h3><p>进程的三种状态</p>
<ul>
<li>运行：进程要么在<code>CPU</code>上运行，要么在等待被执行且最终会被内核调度</li>
<li>停止：进程的执行被挂起，且不会被调度。当收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>信号时，进程就停止，知道接收到<code>SIGCONT</code>信号</li>
<li>终止：进程永远地停止了，停止地原因有<ul>
<li>收到信号，该信号默认行为为终止进程</li>
<li>从主程序返回</li>
<li>调用<code>exit</code>函数</li>
</ul>
</li>
</ul>
<p><code>exit</code>函数以<code>status</code>退出状态来终止进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br></code></pre></td></tr></table></figure>

<p>父进程通过<code>fork</code>函数创建新的运行的子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">子进程返回0，父进程返回子进程的PID，出错为-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>新创建的子进程几乎与父进程相同。子进程与父进程具有相同的用户级虚拟空间地址，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，因此子进程可以读写父进程中打开的任何文件。父进程与子进程的区别在于它们具有不同的<code>PID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s: %s\n&quot;</span>,msg,strerror(errno));<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//fork函数有两个返回值</span><br>    <span class="hljs-comment">//父进程返回子进程的PID</span><br>    <span class="hljs-comment">//子进程返回0</span><br>	<span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>		unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>	<span class="hljs-keyword">return</span> pid;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main\n&quot;</span>);<br>	pid = Fork();<br>	<span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child : x=%d\n&quot;</span>,++x);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID:%d\n&quot;</span>,pid);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: x=%d\n&quot;</span>,--x);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID:%d\n&quot;</span>,pid);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>fork</code>函数特点</p>
<ul>
<li>调用一次，返回两次。一次返回到父进程，一次返回到子进程。</li>
<li>并发执行。父进程与子进程是独立并发的进程并且内核能够以任意方式交替执行它们逻辑控制流中的指令。</li>
<li>两者相同但是具有独立的地址空间。</li>
<li>共享文件。父进程与子进程都将输出打印在屏幕上，原因上子进程继承了父进程所有的打开文件。当父进程调用<code>fork</code>时,<code>stdout</code>文件时打开的，并指向屏幕。子进程继承了该文件，因此也会向屏幕输出。</li>
</ul>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220610233208043.png" srcset="/img/loading.gif" lazyload alt="image-20220610233208043"></p>
<p><code>gdb</code>调试<code>fork()</code>函数</p>
<ul>
<li>调试父进程：<code>set follow-fork-mode parent</code></li>
<li>调试子进程：<code>set follow-fork-mode child</code></li>
</ul>
<p><strong>练习题8.2 考虑下面的程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(Fork() == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1: x=%d\n&quot;</span>,++x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2: x=%d\n&quot;</span>,--x);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>A.子进程的输出是<code>p1: x = 2</code>，<code>p2: x=1</code></li>
<li>B.父进程的输出是<code>p2：x=0</code></li>
</ul>
<h3 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h3><p>进程因为某种原因终止时，内核并不是立即把它从系统中清除。进程被标志为已终止状态，直到它被父进程回收。</p>
<p>当父进程回收已终止的子进程的时候，内核就会将子进程的退出状态传递给父进程，并且抛弃已终止进程，此时该进程就不存在系统中。</p>
<p>若已终止进程未被回收则称之为僵尸进程。</p>
<p><code>init</code>进程是所有进程的父进程，负责回收孤儿进程（即父进程终止，但其子进程还存在，存在的子进程被称之为孤儿进程）。</p>
<p><code>init</code>进程的<code>PID</code>为1，不会终止。是在系统启动的时候由内核创建的。</p>
<p>僵尸进程仍然会消耗系统的内存资源。</p>
<p><code>waitpid</code>函数用于等到它的子进程终止或者停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">int</span> *statusp, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">//返回：成功返回子进程PID，否则返回0，其他错误返回-1</span><br></code></pre></td></tr></table></figure>

<p>默认情况下（<code>options=0</code>)，<code>waitpid</code>挂起调用进程的指向，直到它的集合中的一个子进程终止。</p>
<p><strong>1.判定等待集合的成员</strong></p>
<p>等待集合的成员由参数<code>pid</code>确定</p>
<ul>
<li><code>pid</code>&gt;0，只等待进程<code>ID</code>等于<code>pid</code>的子进程</li>
<li><code>pid</code> &#x3D; -1，等待任何一个子进程退出</li>
<li><code>pid</code> &#x3D; 0，等待同一个进程组中的任何自己才能</li>
<li><code>pid</code> &lt; -1，等待一个指定进程组中的任何子进程，这个进程组的<code>ID</code>等于<code>pid</code>的绝对值</li>
</ul>
<p><strong>2.修改默认行为</strong></p>
<p><code>options</code>可以设置为<code>WNOHANG</code>、<code>WUNTRACED</code>和<code>WCONTINUED</code>或者这几种的组合</p>
<ul>
<li><code>WNOHANG</code>：如果等待集合中的任何子进程都还没有终止，那么就立即返回(返回值为0)。</li>
</ul>
<p>例子（参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/tycoon1988/article/details/40976807">Linux    waitpid用WNOHANG</a>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pc,pr;<br>	<br>	pc = fork();<br>	<span class="hljs-keyword">if</span>(pc &lt; <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pc == <span class="hljs-number">0</span>)<br>	&#123;<br>		sleep(<span class="hljs-number">10</span>);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">do</span>&#123;<br>			pr = waitpid(pc,<span class="hljs-literal">NULL</span>,WNOHANG);<br>			<span class="hljs-keyword">if</span>( pr == <span class="hljs-number">0</span>)<br>			&#123;	<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No child exit\n&quot;</span>);<br>				sleep(<span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<span class="hljs-keyword">while</span>(pr == <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> ( pr == pc)<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;successfully get child %d\n&quot;</span>,pr);<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait child error\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/11/MiaQ6TXko7m1ySc.png" srcset="/img/loading.gif" lazyload alt="image-20220611005605666"></p>
<ul>
<li><code>WUNTRACED</code>：挂起调用进程的指向，直到等待集合中的一个进程变成已终止或者被停止。返回的<code>PID</code>为已终止或被停止子进程的<code>PID</code>。默认的行为是只返回已终止的子进程。</li>
<li><code>WCONTINUED</code>：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程搜到<code>SIGCONT</code>信号重新开始执行。</li>
</ul>
<p><strong>3.检查已回收子进程的退出状态</strong></p>
<p>若<code>statusp</code>参数是飞控的，那么<code>waitpid</code>就会在<code>status</code>中放上关于导致返回的子进程的状态信息，<code>status</code>是<code>statusp</code>指向的值。<code>wait.h</code>头文件定义了解释<code>status</code>参数的几个宏</p>
<ul>
<li><code>WIFEXITED</code>：如果子进程通过调用<code>exit</code>或者一个返回正常终止，就返回真</li>
<li><code>WEXITSTATUS</code>：返回一个正常终止的子进程的退出状态。只有当<code>WIFEXITED()</code>返回真时，才会定义这个状态。</li>
<li><code>WIFSIGNALED</code>：如果子进程时因为一个未捕获的信号终止的，那么就返回真</li>
<li><code>WTERMSIG</code>：返回导致子进程终止的信号编号。只有在<code>WIFSIGNALED()</code>返回为真时，才定义这个状态。</li>
<li><code>WIFSTOPPED</code>：如果引起返回的子进程当前是停止的，那么就返回真</li>
<li><code>WSTOPSIG</code>：返回引起子进程停止的信号和编号。只有在<code>WIFSTOPPED()</code>返回为真时，才定义这个状态。</li>
<li><code>WIFCONTINUED</code>：如果子进程收到<code>SIGCONT</code>信号重新启动，则返回真。</li>
</ul>
<p><strong>4.错误条件</strong></p>
<p>如果调用进程没有子进程，那么<code>waitpid</code>返回<code>-1</code>，并且设置<code>errno</code>为<code>ECHILD</code></p>
<p>如果<code>waitpid</code>函数被一个信号中断，那么它返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code></p>
<p>使用<code>man</code> + 函数名可以查询需要导入的头文件</p>
<p><strong>练习题8.3</strong></p>
<p>列出下面程序所有可能的输出序列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>        waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/11/mK6DnhsxCRkGMU2.png" srcset="/img/loading.gif" lazyload alt="image-20220611011515337"></p>
<p><strong>5.wait 函数</strong></p>
<p><code>wait</code>函数时<code>waitpid</code>函数的简单版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *statusp)</span>;<br></code></pre></td></tr></table></figure>

<p>调用<code>wait(&amp;status)</code>等价于调用<code>waitpid(-1，&amp;status，0)</code></p>
<p><strong>6. 使用waitpid的示例</strong></p>
<p><strong>waitpid1.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;	<br>	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s:%s\n&quot;</span>,msg,strerror(errno));<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>		unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>	<span class="hljs-keyword">return</span> pid;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> status,i;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N;i++) <span class="hljs-comment">//fork两个子进程</span><br>		<span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">100</span>+i); <span class="hljs-comment">//退出状态</span><br>	<br>	<span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status,<span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//等到任意进程终止</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid:%d\n&quot;</span>,pid);<br>		<span class="hljs-keyword">if</span>(WIFEXITED(status)) <span class="hljs-comment">//调用exit函数退出则执行</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chid %d terminated normally with exit status=%d\n&quot;</span>,pid,WEXITSTATUS(status));<span class="hljs-comment">//打印终止的进程ID即状态号</span><br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated abnormally\n&quot;</span>,pid);<br>	&#125;<br>	<br>	<span class="hljs-keyword">if</span> (errno != ECHILD)<br>		unix_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>waitpid2.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N  2</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s:%s\n&quot;</span>,msg,strerror(errno));<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span> )<br>		unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>	<span class="hljs-keyword">return</span> pid;	<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> status,i;<br>	<span class="hljs-type">pid_t</span> pid[N], retpid;<br>	<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>		<span class="hljs-keyword">if</span>((pid[i] = Fork()) == <span class="hljs-number">0</span>)<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">100</span>+i);<br>	<br>	i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//pid &gt; 0 等待指定的子进程退出</span><br>	<span class="hljs-keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status,<span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span> (WIFEXITED(status))<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>,retpid,WEXITSTATUS(status));<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated abnormally\n&quot;</span>,retpid); <br>	&#125;<br>	<span class="hljs-keyword">if</span>(errno != ECHILD)<br>		unix_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>练习题8.4</strong></p>
<p>考虑下面的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>    pid = Fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,!pid);<br>    <span class="hljs-keyword">if</span>(pid != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (waitpid(<span class="hljs-number">-1</span>,&amp;status,<span class="hljs-number">0</span>)&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(WIFEXITED(status)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,WEXITSTATUS(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bye\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A.这个程序会产生多少输出行</p>
<p><img src="https://s2.loli.net/2022/06/11/uhPyHwYE9d5evgf.png" srcset="/img/loading.gif" lazyload alt="image-20220611121332443"></p>
<p>B.这些输出行的一种可能顺序是什么？</p>
<p><img src="F:\CTF\787e781cc849bb40e68b8e58237ade5.jpg" srcset="/img/loading.gif" lazyload alt="787e781cc849bb40e68b8e58237ade5"></p>
<h3 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h3><p><code>sleep</code>函数将一个进程挂起一段指定的时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;<br></code></pre></td></tr></table></figure>

<p>若请求时间到了，<code>sleep</code>返回<code>0</code>，否则返回还剩下的要休眠的秒数。<code>sleep</code>函数有可能会被信号中断过早地返回。</p>
<p><code>pause</code>函数让调用函数休眠，直到该进程收到一个信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><strong>练习题8.5</strong></p>
<p>编写一个<code>sleep</code>地包装函数，叫做<code>snooze</code>，带有下面地接口：</p>
<p><code>unsigned int snooze(unsigned int secs)</code>;</p>
<p><code>snooze</code>函数和<code>sleep</code>函数地行为完全一样，除了它会打印出一条消息来描述进程实际休眠了多长时间：</p>
<p>Slept for 4 of secs.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">snooze</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rc = sleep(secs);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Slept for %d of %d secs\n&quot;</span>,secs - rc, secs);<br>	<span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rc;<br>	rc = snooze(<span class="hljs-number">5</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h3><p><code>execve</code>函数在当前进程地上下文中加载并运行一个新程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[], <span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span>;<br><span class="hljs-comment">//成功则不返回，错误则返回-1</span><br></code></pre></td></tr></table></figure>

<p><code>execve</code>调用一次并不返回</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611130234576.png" srcset="/img/loading.gif" lazyload alt="image-20220611130234576"></p>
<p>当<code>main</code>函数开始执行时，用户栈地组织结构为下图</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611163804777.png" srcset="/img/loading.gif" lazyload alt="image-20220611163804777"></p>
<p><code>int main(int argc, char **argv, char **envp);</code></p>
<p><code>int main(int argc,char *argv[], char *envp[]);</code></p>
<p><code>main</code>函数有3个参数</p>
<ol>
<li><code>argc</code>，指的是<code>argv[]</code>数组中非空指针地数量</li>
<li><code>argv</code>，指向<code>argv[]</code>数组中的第一个条目</li>
<li><code>envp</code>，指向<code>envp[]</code>数组中的第一条目</li>
</ol>
<p><code>Linux</code>用于操作环境数组的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">//返回：若存在则为指向name的指针，若无匹配的，则为NULL</span><br></code></pre></td></tr></table></figure>

<p><code>getenv</code>函数在环境数组中搜索字符串<code>name =  value</code>。如果找到返回指向<code>value</code>的指针，否则返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *newvalue, <span class="hljs-type">int</span> overwrite)</span>;<br><span class="hljs-comment">//返回：若成功则为0，若错误则为-1</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unsetenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">//返回：无</span><br></code></pre></td></tr></table></figure>

<p>如果环境数组包含一个形如<code>name = oldvalue</code>的字符串，那么<code>unsetenv</code>会删除指定键值对，而使用<code>setenv</code>会使用<code>newvalue</code>代替<code>oldvalue</code>，但是只有在<code>overwrite</code>为非零时才会覆盖。</p>
<p>如果<code>name</code>不存在，那么<code>setenv</code>酒吧<code>name = new value</code>添加到数组中。</p>
<p>程序与进程的区别</p>
<ul>
<li>程序是一堆代码和数据，作为目标文件存在于磁盘上。进程则是执行程序的实例。</li>
<li>程序是运行在进程的上下文中的</li>
</ul>
<p><strong>练习题8.6</strong></p>
<p>编写一个叫做<code>myecho</code>的程序，打印出它的命令行参数和环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[],<span class="hljs-type">char</span> *envp[])</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Command-ine arguments:&quot;</span>);<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i++)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[ %d]: %s\n&quot;</span>,i,argv[i]);<br>	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enviroment variables:&quot;</span>);<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(envp); i++)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;envp[ %d]: %s\n&quot;</span>,i,envp[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/11/TwRvgDjtkzSObxo.png" srcset="/img/loading.gif" lazyload alt="image-20220611170151025"></p>
<p>课后答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[],<span class="hljs-type">char</span> *envp[])</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Command-ine arguments:&quot;</span>);<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; argv[i] != <span class="hljs-literal">NULL</span>; i++)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[%2d]: %s\n&quot;</span>,i,argv[i]);<br>	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Environment variables:&quot;</span>);<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; envp[i] != <span class="hljs-literal">NULL</span>; i++)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;envp[%2d]: %s\n&quot;</span>,i,envpc[i]);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-4-6-利用fork和execve运行程序"><a href="#8-4-6-利用fork和execve运行程序" class="headerlink" title="8.4.6 利用fork和execve运行程序"></a>8.4.6 利用fork和execve运行程序</h3><p><strong>shellex.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//gcc -o shellex shellex.c csapp.c -lpthread</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXARGS 128</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">parseline</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">char</span> **argv)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_command</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> cmdline[MAXLINE];<br>	<br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>		Fgets(cmdline,MAXLINE,<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//输入命令</span><br>		<span class="hljs-keyword">if</span>(feof(<span class="hljs-built_in">stdin</span>))<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		eval(cmdline);<span class="hljs-comment">//解析命令</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span><br>&#123;<br>	<span class="hljs-type">char</span> *argv[MAXARGS];<br>	<span class="hljs-type">char</span> buf[MAXLINE];<br>	<span class="hljs-type">int</span> bg;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<br>	<span class="hljs-built_in">strcpy</span>(buf,cmdline);<span class="hljs-comment">//将命令拷贝到buf数组中</span><br>	bg = parseline(buf,argv);<span class="hljs-comment">//解析命令，将空格转换为截断符，将转换后的命令放在argv中</span><br>	<span class="hljs-keyword">if</span>( argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span>;<br>	<br>	<span class="hljs-keyword">if</span>(!builtin_command(argv))&#123;<br>		<span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">if</span>(execve(argv[<span class="hljs-number">0</span>],argv,environ) &lt; <span class="hljs-number">0</span>)&#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>				<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">if</span>(!bg)&#123;<br>		<span class="hljs-type">int</span> status;<br>		<span class="hljs-keyword">if</span> (waitpid(pid,&amp;status,<span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>			unix_error(<span class="hljs-string">&quot;waitfd: waitpid error&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s&quot;</span>,pid,cmdline);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_command</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;quit&quot;</span>))<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;&amp;&quot;</span>))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">parseline</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-type">char</span> *delim;<br>	<span class="hljs-type">int</span> argc;<br>	<span class="hljs-type">int</span> bg;	<br>	<br>	buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//末尾改为空格</span><br>	<span class="hljs-keyword">while</span>(*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">//跳过空格</span><br>		buf++;<br>	argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定位空格位置</span><br>	<span class="hljs-keyword">while</span>((delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>)))&#123;<br>		argv[argc++] = buf;<br>		*delim = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		buf = delim + <span class="hljs-number">1</span>; <span class="hljs-comment">//跳过空格</span><br>		<span class="hljs-keyword">while</span>(*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">//避免参数之间含有多个空格，空格全跳过</span><br>			buf++;<br>	&#125;<br>	argv[argc] = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>((bg = (*argv[argc<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>)<span class="hljs-comment">//判断最后一个字符是否为&amp;，若是则后台运行进程</span><br>		argv[--argc] = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> bg;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h2><p><code>Linux</code>信号允许进程和内核中断其他进程。</p>
<p>底层硬件异常由内核异常处理程序处理，用户程进程不可见。因此信号提供一种机制，可以通知用户进程发生了异常。</p>
<p><img src="https://s2.loli.net/2022/06/11/RDeNJFgmjy2tu6O.png" srcset="/img/loading.gif" lazyload alt="image-20220611191313999"></p>
<p>按下<code>Ctrl+C</code>，内核将会发送<code>SIGINT</code>信号给前台进程组的每个进程。</p>
<p>一个进程可以通过向另一个进程发送<code>SIGKILL</code>信号强制终止它。</p>
<p>当一个子进程终止或停止时，内核会发送一个<code>SIGCHLD</code>信号给父进程</p>
<h4 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h4><p>传送信号到目的进程的步骤：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。</li>
<li>接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号</li>
</ul>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220611202438537.png" srcset="/img/loading.gif" lazyload alt="image-20220611202438537"></p>
<p>没有被接收的信号称之为待处理信号，一种信号至多只有一个待处理信号，若此时接收了相同类型的信号则直接抛弃，不会进行排队等号。</p>
<p>进程可以有选择性的阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<h4 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h4><p><code>Unix</code>系统提供了向进程发送信号的机制，这些机制都是基于进程组概念。</p>
<p><strong>1.进程组</strong></p>
<p>每个进程都只属于一个进程组，进程组由一个正整数进程组ID标识。</p>
<p><code>getpgrp</code>函数返回当前进程的进程组<code>ID</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgrp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">//返回：调用进程的进程组ID</span><br></code></pre></td></tr></table></figure>

<p>默认条件下，子进程与它的父进程同属于一个进程组。</p>
<p>进程可以通过<code>setpgid</code>函数改变自己或其他进程的进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;<br><span class="hljs-comment">//成功则返回0，错误则为-1</span><br></code></pre></td></tr></table></figure>

<ul>
<li>若<code>pid</code>为0，则使用当前进程的<code>PID</code></li>
<li>若<code>pgid</code>为0，则使用<code>pid</code>指定的进程的<code>PID</code>作为进程组<code>ID</code></li>
</ul>
<p><strong>2. 用&#x2F;bin&#x2F;kill程序发送信号</strong></p>
<p><code>/bin/kill</code>程序可以向另外的进程发送任意的信号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 15213</span><br></code></pre></td></tr></table></figure>

<p>发送一个<code>SIGKILL</code>信号给进程15213</p>
<p>负的<code>PID</code>则会将信号被发送到进程组<code>PID</code>中的每个进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 -15213</span><br></code></pre></td></tr></table></figure>

<p>发送一个<code>SIGKILL</code>信号给进程组15213中的每个进程</p>
<p><strong>3.从键盘发送信号</strong></p>
<p><code>Unix shell</code>使用作业表示为对一条命令行求值而创建的进程。</p>
<p>至多只有一个前台作业或0个或多个后台作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash"><span class="hljs-built_in">ls</span> | <span class="hljs-built_in">sort</span></span><br></code></pre></td></tr></table></figure>

<p>上述命令会创建一个由两个进程组成的前台作业，这两个进程是通过<code>Unix</code>管道连接起来</p>
<p><code>shell</code>为每个作业创建一个独立的进程组，进程组<code>ID</code>通常取父进程的<code>PID</code></p>
<p><img src="https://s2.loli.net/2022/06/11/a5PKihr2qIzn1GM.png" srcset="/img/loading.gif" lazyload alt="image-20220611205347003"></p>
<p><code>Ctrl + C</code>往前台进程组发送<code>SIGINT</code>信号，终止前台作业</p>
<p><code>Ctrl + z</code>往前台进程发送<code>SIGTSTP</code>信号，挂起前台作业</p>
<p><strong>4.用kill函数发送信号</strong></p>
<p>进程通过调用<code>kill</code>函数发送洗脑给其他进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>pid&gt;0</code>，这<code>kill</code>函数发送信号号码<code>sig</code>给进程<code>pid</code></p>
</li>
<li><p><code>pid = 0</code>，则<code>kill</code>函数发送信号<code>sig</code>给调用进程所在进程组中的每个进程，包括调用进程自己</p>
</li>
<li><p><code>pid &lt; 0</code>，<code>kill</code>函数发送信号<code>sig</code>给进程组<code>pid</code>中的每个进程</p>
</li>
</ul>
<p><strong>kill.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)&#123;<br>		Pause();<span class="hljs-comment">//休眠进程等待信号</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;control should never reach here!\n&quot;</span>);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br>	<br>	Kill(pid,SIGKILL);<span class="hljs-comment">//给子进程发送杀死进程的信号</span><br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>5.用alarm函数发送信号</strong></p>
<p>进程可以通过<code>alarm</code>函数向它自己发送<code>SIGALRM</code>信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;<br></code></pre></td></tr></table></figure>

<p><code>alarm</code>被称为闹钟函数，可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送<code>SIGALRM</code>信号，其动作是终止调用该<code>alarm</code>函数的进程</p>
<h4 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h4><p>当进程从内核态转化为用户态时，内核会检测进程是否存在未被阻塞且待处理信号的集合。若有则内核会选择某个信号（通常为最小值的信号），并且强制进程接收信号。</p>
<p>进程接收信号后会采取某种行为，每个信号都有一个预定义的默认行为</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存</li>
<li>进程停止（挂起）直到被<code>SIGCONT</code>信号重启</li>
<li>进程忽略该信号</li>
</ul>
<p>信号的默认行为可以通过<code>signal</code>函数修改，除了<code>SIGSTOP</code>和<code>SIGKILL</code>信号不能被修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,<span class="hljs-type">sighandler_t</span> handler)</span>;<br><br><span class="hljs-comment">//返回：若成功则为指向前次处理程序的指针，出错则为SIG_ERR</span><br></code></pre></td></tr></table></figure>

<p><code>signal</code>函数可以通过三种方法来修改和信号<code>signum</code>相关联的行为</p>
<ul>
<li><code>handler</code>是<code>SIG_IGN</code>，那么忽略类型为<code>signum</code>的信号</li>
<li><code>handler</code>是<code>SIG_DFL</code>，那么类型为<code>signum</code>的信号行为恢复为默认行为（处理信号）</li>
<li>否则，<code>handler</code>就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为<code>signum</code>的信号，就会调用这个程序。通过把处理程序的地址传递给<code>signal</code>函数从而改变默认行为，这叫设置信号处理程序。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-comment">//捕获到SIGINT信号的处理函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nCaught SIGINT!\n&quot;</span>);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-keyword">if</span>(signal(SIGINT,sigint_handler) == SIG_ERR)<br>		unix_error(<span class="hljs-string">&quot;signal error&quot;</span>);<br>	pause(); <span class="hljs-comment">//挂起进程直到收到信号</span><br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-5-4-阻塞和解除阻塞信号"><a href="#8-5-4-阻塞和解除阻塞信号" class="headerlink" title="8.5.4 阻塞和解除阻塞信号"></a>8.5.4 阻塞和解除阻塞信号</h4><p>Linux提供阻塞信号的隐式和显式的机制：</p>
<ul>
<li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。即每个信号都有对应的信号处理程序，在该信号处理程序执行时会默认阻塞该信号</li>
<li>显示阻塞机制。应用程序可以使用<code>sigprocmask</code>函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemtyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>,<span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">//成功则返回0，出错则为-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>,<span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">//若signum是set的成员则为1，不是则为0，出错则为-1</span><br><br></code></pre></td></tr></table></figure>

<p><code>sigprocmask</code>函数改变当前阻塞的信号集合，具体行为依赖于<code>how</code>的值</p>
<ul>
<li><code>SIG_BLOCK</code>：把<code>set</code>中的信号添加到<code>blocked</code>中（<code>blocked=blocked | set</code>）</li>
<li><code>SIG_UNBOCK</code>：从<code>blocked</code>中删除<code>set</code>中的信号(<code>blocked = blocked &amp; ~set</code>)</li>
<li><code>SIG_SETMASK</code>：<code>block = set</code></li>
</ul>
<p>如果<code>oldset</code>非空，那么<code>blocked</code>位向量之前的值保存在<code>oldset</code>中</p>
<p>对<code>set</code>信号集合进行操作的函数</p>
<ul>
<li><code>sigemptyset</code>初始化<code>set</code>为空集合</li>
<li><code>sigfillset</code>函数把每个信号都添加到<code>set</code>中</li>
<li><code>sigaddset</code>函数把<code>signum</code>添加到<code>set</code></li>
<li><code>sigdelset</code>从<code>set</code>中删除<code>signum</code></li>
</ul>
<p><code>sigprocmask</code>临时阻塞接收<code>SIGINT</code>信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sigset_t</span> mask,prev_mask;<br>Sigemptyset(&amp;mask);<br>Sigaddset(&amp;mask,SIGINT);<br><br><span class="hljs-comment">//将修改之前的信号存放在prev_mask中</span><br>Sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev_mask);<br><br><span class="hljs-comment">//还原之前的设置</span><br>Sigprocmask(SIG_SETMASK,&amp;prev_mask,<span class="hljs-literal">NULL</span>);<br><br></code></pre></td></tr></table></figure>

<h4 id="8-5-5-编写信号处理程序"><a href="#8-5-5-编写信号处理程序" class="headerlink" title="8.5.5 编写信号处理程序"></a>8.5.5 编写信号处理程序</h4><p><strong>1.安全的信号处理</strong></p>
<p>信号处理程序由于是与主程序以及其他信号处理程序并发地允许，因此可以并发地访问同样地全局数据结构，那么可能会造成不可预知地问题。</p>
<p>编写处理程序的原则</p>
<ul>
<li>处理程序要尽可能简单</li>
<li>在处理程序中只调用异步信号安全的函数。<ul>
<li>异步信号安全的函数是可重入的（只访问局部变量）</li>
<li>异步信号安全的函数不能被信号处理程序中断</li>
</ul>
</li>
</ul>
<p><strong>异步信号安全的函数</strong></p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220613172343468.png" srcset="/img/loading.gif" lazyload alt="image-20220613172343468"></p>
<p>信号处理程序中产生输出唯一安全的方法是使用<code>write</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sio_putl</span><span class="hljs-params">(<span class="hljs-type">long</span> v)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sio_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sio_error</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span>;<br></code></pre></td></tr></table></figure>

<p><strong>code&#x2F;src&#x2F;csapp.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sio_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span><br>&#123;<br>    <span class="hljs-comment">//sio_strlen函数返回字符串s的长度</span><br>    <span class="hljs-keyword">return</span> write(STDOUT_FILENO,s,sio_strlen(s));<br>&#125;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sio_putl</span><span class="hljs-params">(<span class="hljs-type">long</span> v)</span><br>&#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">128</span>];<br>    <br>    <span class="hljs-comment">//长整形转化为任意进制的字符串</span><br>    sio_ltoa(v,s,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> sio_puts(s);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sio_error</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span><br>&#123;<br>    sio_puts(s);<br>    _exit(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>SIGINT</strong>处理程序的安全版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handle</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    	Sio_puts(<span class="hljs-string">&quot;Caught SIGINT!\n&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>保存和恢复<code>errno</code>。由于众多<code>Linux</code>异步信号安全的函数都会在出错返回时设置<code>errno</code>。由于处理程序可能会干扰其他主程序中其他依赖于<code>errno</code>。因此解决办法为是在进入处理程序时将<code>errno</code>保存在一个局部变量中，在处理程序返回前恢复</li>
<li>阻塞所有的信号，保护对共享全局数据结构的访问。</li>
<li>用<code>volatile</code>声明全局变量。若用处理程序和<code>main</code>函数共享一个全局变量<code>g</code>，由于<code>main</code>周期性读<code>g</code>。一个优化的编译器会使用缓存在寄存器中的<code>g</code>的副本来满足对<code>g</code>对每次引用。则导致<code>main</code>无法读取<code>g</code>更新过的值<ul>
<li><code>volatile</code>类型限定符来定义一个变量，告诉编译器不要缓存这个变量。强迫编译器每次在代码中引用<code>g</code>时，都要从内存中读取。</li>
</ul>
</li>
<li>用<code>sig_atomic_t</code>声明标志。处理程序通过写全局标志来记录收到的信号。主程序周期性地读这个标志，响应信号，再清除标志。对于通过这种方式来共享地标志，<code>C</code>提供一种整型数据类型<code>sig_atomic_t</code>，并且该类型的读写是保证是原子操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">sig_atomic_t</span> flag;<br></code></pre></td></tr></table></figure>

<p><strong>2. 正确的信号处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler1</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>	<span class="hljs-type">int</span> olderrno = errno;<br>	<br>	<span class="hljs-keyword">if</span>((waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>		sio_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>	Sio_puts(<span class="hljs-string">&quot;Handler reaped child\n&quot;</span>);<br>	Sleep(<span class="hljs-number">1</span>);<br>	errno = olderrno;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> i,n;<br>	<span class="hljs-type">char</span> buf[MAXBUF];<br>	<br>	<span class="hljs-keyword">if</span>(signal(SIGCHLD,handler1) == SIG_ERR)<br>		unix_error(<span class="hljs-string">&quot;signal error&quot;</span>);<br>	<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>		<span class="hljs-keyword">if</span>(Fork() == <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from child %d\n&quot;</span>,(<span class="hljs-type">int</span>)getpid());<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">if</span>((n = read(STDIN_FILENO,buf,<span class="hljs-keyword">sizeof</span>(buf))) &lt; <span class="hljs-number">0</span>)<br>		unix_error(<span class="hljs-string">&quot;read&quot;</span>);<br>		<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent processing input\n&quot;</span>);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>	;<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序会导致僵尸进程。父进程接收并捕获了第一个信号，当处理程序还在处理第一个程序时，第二个信号就传送并添加到待处理信号集合里，然而，因为<code>SIGCHLD</code>信号被<code>SIGCHLD</code>处理程序阻塞了，所以第二个信号不会被接收，因此再第三个信号时，该信号会被抛弃，导致进程未被收回。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220613200712252.png" srcset="/img/loading.gif" lazyload alt="image-20220613200712252"></p>
<p><strong>code&#x2F;ecf&#x2F;signal2.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">handler2</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    <span class="hljs-comment">//将所有子进程都回收，则不会导致有僵尸进程</span><br>    <span class="hljs-keyword">while</span>(waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>)&gt;<span class="hljs-number">0</span>)&#123;<br>        Sio_puts(<span class="hljs-string">&quot;Handler reaped child\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(errno != ECHILD)<br>        Sio_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>    Sleep(<span class="hljs-number">1</span>);<br>    errno = olderrno;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>练习题8.8</strong></p>
<p>下面这个程序的输出是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> counter = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//子进程调用信号处理函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler1</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> mask,prev_mask;<br>    <span class="hljs-comment">//将所有信号放进mask里</span><br>    Sigfillset(&amp;mask);<span class="hljs-comment">//将信号都放进mask中</span><br>    <span class="hljs-comment">//临时阻塞所有信号</span><br>    Sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev_mask);<br>    <span class="hljs-comment">//此时是子进程取出它自己的counter变量</span><br>    Sio_putl(--counter);<span class="hljs-comment">//打印1</span><br>    <span class="hljs-comment">//还原信号</span><br>    Sigprocmask(SIG_SETMASK,&amp;prev_mask,<span class="hljs-literal">NULL</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">sigset_t</span> mask,prev_mask;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,counter);<span class="hljs-comment">//用户打印2</span><br>    fflush(<span class="hljs-built_in">stdout</span>);<br>    <br>    signal(SIGUSR1,handler1); <span class="hljs-comment">//用户定义的信号1</span><br>    <span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;&#125;; <span class="hljs-comment">//死循环</span><br>    &#125;<br>    Kill(pid,SIGUSR1);<span class="hljs-comment">//父进程给子进程发送用户定义的信号1</span><br>    Waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//将所有信号放进mask里</span><br>    Sigfillset(&amp;mask);<br>    Sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev_mask);<br>    <span class="hljs-comment">//此时是父进程取出它自己的counter变量</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,++counter);<span class="hljs-comment">//打印3</span><br>    Sigprocmask(SIG_SETMASK,&amp;prev_mask,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出213</p>
<p><strong>3.可移植的信号处理</strong></p>
<p><code>Unix</code>信号处理的另一个缺陷在于不同的系统有不同的信号处理语义</p>
<ul>
<li><code>signal</code>函数的语义各有不同。在有些老的<code>Unix</code>系统在信号<code>k</code>被处理程序捕获之后就把对信号<code>k</code>的反应恢复到默认值。因此在这些系统上，每次运行之后，处理程序必须调用<code>signal</code>函数，显示地重新设置。</li>
<li>系统调用可以被中断。像<code>read</code>、<code>write</code>和<code>accept</code>这样的系统调用潜在地会阻塞进程一段时间，称之为慢速系统调用。在老的<code>Unix</code>系统中，当处理程序捕获到一个信号时，被中断地慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将<code>errno</code>设置为<code>EINTR</code>，因此在这些系统上程序员需要手动重启被中断的系统调用的代码。</li>
</ul>
<p><code>sigaction</code>函数允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,<span class="hljs-keyword">struct</span> sigaction *atc, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br><span class="hljs-comment">//成功则返回0，出错则为-1</span><br></code></pre></td></tr></table></figure>

<p>定义一个包装函数，称之为<code>Signal</code>调用<code>sigaction</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">handler_t</span> *<span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,<span class="hljs-type">handler_t</span> *handler)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br>    action.sa_handler = handler;<br>    sigemptyset(&amp;action.sa_mask);<br>    action.sa_flags = SA_RESTART;<br>    <br>    <span class="hljs-keyword">if</span>(sigaction(signum,&amp;action,&amp;old_action) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>   <span class="hljs-keyword">return</span>(old_action.sa_handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-5-6-同步流以避免讨厌的并发错误"><a href="#8-5-6-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.6 同步流以避免讨厌的并发错误"></a>8.5.6 同步流以避免讨厌的并发错误</h4><p><strong>code&#x2F;ecf&#x2F;procmask1.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    <span class="hljs-type">sigset_t</span> mask_all, prev_all;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    Sigfillset(&amp;mask_all);<br>    <span class="hljs-keyword">while</span>((pid = waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>))&gt;<span class="hljs-number">0</span>)&#123;<br>        Sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);<br>        deletejob(pid);<br>        Sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(errno != ECHILD)<br>        Sio_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>   	errno = olderrno;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-type">sigset_t</span> mask_all,prev_all;<br>    <br>    Sigfillset(&amp;mask_all);<br>    Signal(SIGCHLD,handler);<br>    initjobs();<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)&#123;<br>            Execve(<span class="hljs-string">&quot;/bin/date&quot;</span>,argv,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>        Sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);<br>        addjob(pid);<br>        Sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码可能会导致条件竞争</p>
<ul>
<li>父进程执行<code>fork</code>函数，内核调度新创建的子进程运行</li>
<li>子进程终止，传递一个<code>SIGCHLD</code>信号给父进程</li>
<li>父进程执行前发现有未处理的信号</li>
<li>信号处理程序回收终止子进程，并且调用<code>deletejob</code>，但是父进程还没有把子进程放进作业中</li>
<li>信号处理程序完毕后，内核继续运行父进程，父进程从<code>fork</code>返回后，将回收的子进程又添加到作业中</li>
</ul>
<p><strong>code&#x2F;efc&#x2F;procmask2.c</strong></p>
<p>在父进程<code>fork</code>之前阻塞<code>SIGCHLD</code>，在<code>addjob</code>之后才解除，则避免了在<code>addjob</code>之前<code>deletejob</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    <span class="hljs-type">sigset_t</span> mask_all,prev_all;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    Sigfillset(&amp;mask_all);<br>    <span class="hljs-keyword">while</span>((pid = waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>))&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        Sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);<br>        deletejob(pid);<br>        Sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(errno != ECHILD)<br>        Sio_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>    errno = olderrno;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-type">sigset_t</span> mask_all,mask_one,prev_one;<br>    <br>    Sigfillset(&amp;mask_all);<br>    Sigemptyset(&amp;mask_one);<br>    Sigaddset(&amp;mask_one,SIGCHLD);<br>    Signal(SIGCHLD,handler);<br>    initjobs();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        Sigprocmask(SIG_BLOCK,&amp;mask_one,&amp;prev_one);<br>        <span class="hljs-keyword">if</span>((pid = Fork()) == <span class="hljs-number">0</span>)&#123;<br>            Sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="hljs-literal">NULL</span>);<br>            Execve(<span class="hljs-string">&quot;/bin/data&quot;</span>,argv,<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        Sigprocmask(SIG_BLOCK,&amp;mask_all,<span class="hljs-literal">NULL</span>);<br>        addjob(pid);<br>        Sigprocmask(SIG_SETMASK,&amp;prev_one,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-5-7-显示地等待信号"><a href="#8-5-7-显示地等待信号" class="headerlink" title="8.5.7 显示地等待信号"></a>8.5.7 显示地等待信号</h4><p>有时候主程序需要显示地等待某个信号处理程序运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">sig_atomic_t</span> pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    pid = waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    errno = olderrno;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>    <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> mask,prev;<br>    <br>    Signal(SIGCHLD,sigchld_handler);<br>    Signal(SIGINT,sigint_handler);<br>    Sigemptyset(&amp;mask);<br>    Sigaddset(&amp;mast,SIGCHLD);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 		<span class="hljs-comment">//忽略SIGCHLD信号，防止条件竞争</span><br>       Sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);<br>        <span class="hljs-keyword">if</span>(Fork() == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        pid = <span class="hljs-number">0</span>;<br>        Sigprocmask(SIG_SETMASK,&amp;prev,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>(!pid)<span class="hljs-comment">//等到SIGCHLD信号处理程序执行后主程序才接着执行</span><br>            ;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>循环会浪费处理器资源，因此可以修改为其他代码使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(!pid)<br>	pause()<br></code></pre></td></tr></table></figure>

<p>但是若信号在<code>while</code>语句后，<code>pause()</code>语句前到达，那么程序将永久休眠</p>
<p>使用<code>sleep</code>替换<code>pause</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(!pid)<br>	sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>但是使用<code>sleep</code>执行会浪费大量时间，若改为高精度的休眠函数则休眠时间太短则会造成<code>while</code>语句执行次数过多，若休眠时间太长则又会导致程序运行时间太久。</p>
<p>使用函数<code>sigsuspend</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsuspend</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *mask)</span>;<br><br><span class="hljs-comment">//等价于</span><br>sigprocmask(SIG_SETMASK,&amp;mask,&amp;prev);<br>pause();<br>sigprocmask(SIG_SETMASK,&amp;prev,<span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p><strong>code&#x2F;ecf&#x2F;sigsuspend.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">sig_atomic_t</span> pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    pid = waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>    errno = olderrno;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>    <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> mask,prev;<br>    <br>    Signal(SIGCHLD,sigchld_handler);<br>    Signal(SIGINT,sigint_handler);<br>    Sigemptyset(&amp;mask);<br>    Sigaddset(&amp;mast,SIGCHLD);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br> 		<span class="hljs-comment">//忽略SIGCHLD信号，防止条件竞争</span><br>       Sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);<br>        <span class="hljs-keyword">if</span>(Fork() == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        pid = <span class="hljs-number">0</span>;<br>        Sigprocmask(SIG_SETMASK,&amp;prev,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>(!pid)<br>            sigsuspend(&amp;prev);<br> Sigprocmast(SIG_SETMASK,&amp;prev,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h2><p>非本地跳转是通过<code>setjmp</code>和<code>longjmp</code>函数来提供的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> savesigs)</span>;<br><br><span class="hljs-comment">//返回:setjmp返回0，longjmp返回非零。</span><br></code></pre></td></tr></table></figure>

<p><code>setjmp</code>函数在<code>env</code>缓冲区中保存当前调用环境，供后面的<code>longjmp</code>使用，并返回0。</p>
<p>调用环境包括程序计数器、栈指针和通用目的寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_buf env, <span class="hljs-type">int</span> retval)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">siglongjmp</span><span class="hljs-params">(sigjmp_buf env,<span class="hljs-type">int</span> retval)</span>;<br><span class="hljs-comment">//从不返回</span><br></code></pre></td></tr></table></figure>

<p><code>longjmp</code>函数从<code>env</code>缓冲区中恢复调用环境，然后触发一个从最近一次初始化<code>env</code>的<code>setjmp</code>调用的返回。然后<code>setjmp</code>返回，并带有非零的返回值<code>retval</code></p>
<p><strong>code&#x2F;efc&#x2F;setjmp.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br>jmp_buf buf; <span class="hljs-comment">//调用环境</span><br><span class="hljs-type">int</span> error1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> error2 = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>,<span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">switch</span>(setjmp(buf))&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            	foo();<br>            	<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error1 condition in foo\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error2 condition in foo\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unkonw error condition in foo\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//若遇到错误则直接从setjmp返回</span><br>    <span class="hljs-keyword">if</span>(error1)<br>        longjmp(buf,<span class="hljs-number">1</span>);<br>    bar();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//若遇到错误则直接从setjmp返回</span><br>    <span class="hljs-keyword">if</span>(error2)<br>        longjmp(buf,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>longjmp</code>允许它跳过所有中间调用的特性可能会产生意外的后果，例如函数内部分配了资源，应该在函数结束时释放资源，但是由于<code>longjmp</code>跳过了释放的过程导致了内存泄露。</p>
<p><strong>code&#x2F;ecf&#x2F;restart.c</strong></p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br>sigjmp_buf buf;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    siglongjmp(buf,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//设置跳转</span><br>    <span class="hljs-keyword">if</span>(!sigsetjmp(buf,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-comment">//设置信号处理程序</span><br>        Signal(SIGINT,handler);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        Sio_puts(<span class="hljs-string">&quot;restarting\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        Sleep(<span class="hljs-number">1</span>);<br>       Sio_puts(<span class="hljs-string">&quot;processing...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>C++和Java中的软件异常</strong></p>
<p><code>C++</code>和<code>Java</code>提供的异常机制是较高层次的，是C语言的<code>setjmp</code>和<code>longjmp</code>函数的更加结构化的版本。</p>
<p><code>try</code>语句中的<code>catch</code>子句类似于<code>setjmp</code>函数，<code>throw</code>语句类似于<code>longjmp</code>函数</p>
<h2 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h2><ul>
<li><code>STRACE</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</li>
<li><code>PS</code>：列出当前系统中的进程</li>
<li><code>TOP</code>：打印出关于当前进程资源使用的信息</li>
<li><code>PMAP</code>：显示进程的内存映射</li>
<li><code>/proc</code>：一个虚拟文件系统，以<code>ASCII</code>文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容<ul>
<li>输入<code>cat/proc/loadavg</code>可以看到<code>linux</code>系统上的平均负载</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">#计算机基础</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解计算机系统学习笔记</div>
      <div>http://example.com/2023/06/07/深入理解计算机系统/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>hope</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/07/CVE-2022-08475-DirtyPipe/" title="CVE-2022-08475-DirtyPipe">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CVE-2022-08475-DirtyPipe</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86--%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/" title="逆向工程核心原理--代码注入">
                        <span class="hidden-mobile">逆向工程核心原理--代码注入</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
